# NEC Software Library Academic Use Licence Terms (the 'Terms')

# THESE TERMS APPLY TO THE LICENSEE'S USE OF THE "SOFTWARE" AS IDENTIFIED BELOW 
# (INCLUDING ANY PORTION OR ELEMENT OF THE SOFTWARE), INCLUDING ANY UPDATES TO 
# THE SOFTWARE RECEIVED FROM NEC, AND BY DOWNLOADING OR USING THE SOFTWARE (OR 
# RECEIVING ANY UPDATES TO THE SOFTWARE) THE LICENSEE AGREES TO BE BOUND BY THESE 
# TERMS. 

# THESE TERMS ARE A CONTRACTUAL AGREEMENT BETWEEN THE LICENSEE AND NEC. IF THE 
# LICENSEE DOES NOT AGREE TO THESE TERMS, IT CANNOT DOWNLOAD THE SOFTWARE OR USE 
# THE SOFTWARE FOR ANY PURPOSE.


# 1.	Software licence rights for Academic Use

# 1.1	The Licensee is granted a personal, non-exclusive, worldwide, 
# non-transferrable, non-sublicensable, royalty-free and limited licence to use, 
# reproduce, copy, create derivate works of and/or make modifications to the 
# Software solely for Academic Use; and to use and copy the Documentation solely 
# in connection with the rights granted in the foregoing.

# 1.2	The Licensee acknowledges that, unless otherwise expressly agreed in 
# writing by NEC, the licence granted under clause 1.1 does not permit the 
# commercial use of the Software for any purpose, including any distribution or 
# resale of the Software (either directly, or indirectly as part of any package 
# or bundle of software, cloud software or software as a service product), any 
# use in collaborations between academic and commercial entities (including any 
# funding of PhD activities by commercial entities), or any non-commercial use of 
# the Software by a commercial entity.

# 1.3	For the avoidance of doubt, the Licensee is not permitted to use the 
# Software and/or the Documentation under these Terms for any commercial purposes 
# whilst representing that such use is a form of Academic Use. If NEC has the 
# reasonable belief that the Licensee is using the Software and/or the 
# Documentation for any commercial purposes then such use will be deemed a breach 
# of these Terms and NEC may terminate the licence granted under these Terms with 
# immediate effect in accordance with clause 7.2(a).

# 1.4	The Licensee must use the Software and/or the Documentation in 
# accordance with any applicable laws and regulations, including any applicable 
# import and export control laws, associated embargo and sanction rules and 
# regulations relating to the export of software, or materials or products in 
# connection with the export of software. For clarity, the parties acknowledge 
# that the export control laws of United States and the export/import control 
# laws of other countries may govern the use of the Software and/or the 
# Documentation. The Licensee therefore agrees to comply fully with all relevant 
# export laws and regulations, including those of Japan, European Union (and 
# European Union member states), United Kingdom, and the United States, to ensure 
# that the Software and/or the Documentation or any portion thereof is exported, 
# directly or indirectly, in violation of export laws and regulations. This 
# clause will survive the termination or expiration of these Terms.

# 1.5	The Licensee shall ensure that only its Representatives use the 
# Software and that such use is at all times in accordance with these Terms. The 
# Licensee shall procure that each Representative is aware of, and complies with, 
# the obligations and restrictions imposed on the Licensee under these Terms. 

# 1.6	The Licensee shall be liable for the acts and omissions of its 
# Representatives as if they were its own, and shall not provide access to the 
# Software (or permit access by) anyone other than a Representative.

# 1.7	If the Licensee wishes to use the Software, the Documentation and/or 
# any Derivative Works for commercial purposes then it must enter into a separate 
# commercial licence agreement with NEC, on such terms as NEC acting in its sole 
# discretion requires from time to time. For the avoidance of doubt, NEC reserves 
# the right to not enter into any such commercial licence agreement or other 
# arrangements with the Licensee or any third party.


# 2.	Licence rights regarding Derivative Works

# 2.1	If the Licensee develops any derivate works of the Software, any part 
# of the Software and/or any modifications to the Software, either as the result 
# of a pull request received by NEC from the Licensee or a Representative or 
# otherwise (each a 'Derivative Work') or any product or service that uses or 
# incorporates any Derivative Works then:
# (a)	subject to clause 5.1, as between the Licensee and NEC, all 
# Intellectual Property Rights in the Derivative Works belong to and shall remain 
# vested in the Licensee;
# (b)	the Licensee hereby grants to NEC a perpetual, fully paid-up, 
# non-exclusive, royalty-free, transferrable, sublicensable, irrevocable licence 
# to use, copy, modify, reproduce and/or create derivate works of the Derivative 
# Works for any purpose; 
# (c)	the Licensee must provide NEC a copy of the source code of any 
# Derivative Works via its code repository located at https://github.com/nec-research/DIMOS;
# (d)	the Licensee must provide a copy of these Terms with the Derivative 
# Work(s);
# (e)	the Licensee must prominently display "Built using NEC technology" on 
# any related software description, website, user interface, about page, software 
# specification or other technical documentation; and
# (f)	the Licensee must include in any notice text file distributed as part 
# of any Derivate Work: "[Derivate Work] is licensed under the NEC Software 
# Library Academic License. Copyright © 2025 NEC Laboratories Europe GmbH. All 
# Rights Reserved. 

# 2.2	The Licensee is only permitted to use any Derivative Works for Academic 
# Use. The Licensee is not permitted to use any Derivative Works for commercial 
# use, or to permit or otherwise enable any third party to use any Derivative 
# Works for commercial use. Section 1 of the Terms do accordingly apply. 


# 3.	Acceptable use policy

# 3.1	As a condition of use, the Licensee agrees not to use the Software, nor 
# permit it to be used by any Representative or otherwise: 
# (a)	for any purpose that is unlawful under any applicable law or prohibited 
# by these Terms; 
# (b)	to commit any act of fraud or money laundering or otherwise be used in 
# any activities that are deceptive or harmful to others; 
# (c)	to create, store, access, transfer to any third party or otherwise 
# distribute any code or device intended to interfere with, or having the effect 
# of interfering adversely with, the operation of any hardware or software, 
# including any virus, disabling code (including code intended to limit or 
# prevent any use any software or system) or other malicious software (including 
# bugs, worms, logic bombs, malware, trojan horses, ransomware and spyware), or 
# any other material which is unlawful;
# (d)	for the purposes of promoting unsolicited advertising or sending spam, 
# or for the creation or promotion of disinformation;
# (e)	for the purposes of creating, promoting or furthering any defamatory 
# content, including any defamatory statements, images or other media;
# (f)	to simulate communications from any third party service or entity (i.e. 
# phishing communications) in order to collect identity information, 
# authentication credentials, or other information; 
# (g)	in any manner that disrupts the operations, business, equipment, 
# websites or systems of any person or entity (including any denial of service 
# and similar attacks);
# (h)	in any manner that harms or may endanger minors or any other person, or 
# may cause damage or loss to any tangible property or the environment;
# (i)	to gain unauthorised access to or use of any computers, data, systems, 
# accounts or networks of any person;
# (j)	to attempt to circumvent any security controls or mechanisms; 
# (k)	in any manner that engages in or promotes the harassment, abuse, 
# bullying or discrimination of any individuals or groups of individuals; 
# (l)	in any manner that violates, infringes upon, or misappropriates the 
# Intellectual Property Rights or proprietary rights of NEC or any third party; 
# (m)	to sell, publish, rent, lease or otherwise commercialise the Software 
# or any Derivative Work, or assist any third party in relation to the same; or
# (n)	to reverse engineer, decompile or disassemble the Software except and 
# solely to the extent permitted under these Terms.


# 4.	No warranty

# 4.1	The Software and Documentation (including any part thereof and/or any 
# updates provided under these Terms) (together the 'NEC Materials') are provided 
# "as is" and without warranty to the maximum extent permitted by law. To the 
# extent permitted by law, NEC gives no express or implied warranties, 
# guarantees, conditions or obligations under these Terms, including any express 
# or implied terms relating to quality, fitness for any particular purpose, 
# title, non-infringement, or ability to achieve a particular result. 

# 4.2	The Licensee acknowledges that it is solely responsible for determining 
# the appropriateness of using the NEC Materials and assumes any and all risks 
# associated with its use of the NEC Materials, any Derivative Works and/or any 
# other outputs or results relating to any of the foregoing.


# 5.	Intellectual property rights

# 5.1	As between the Licensee and NEC, all rights, including all Intellectual 
# Property Rights, in the NEC Materials belong to and shall remain vested in NEC. 
# Except for the rights expressly granted in these Terms, the Licensee and/or any 
# Representative shall not acquire in any way any title, rights of ownership, or 
# any other Intellectual Property Rights or other rights of any nature in the NEC 
# Materials and no Intellectual Property Rights or other rights are transferred 
# or licensed as a result of these Terms.

# 5.2	The Licensee acknowledges and agrees that certain aspects of the 
# Software provided under these Terms are based on or powered by Open Source 
# Software, either developed by NEC (and which is not based on or derived from 
# Open Source Software licensed to NEC) or derived from, or incorporated into 
# and/or distributed with other Open Source Software licensed to NEC.

# 5.3	NEC may use any feedback and suggestions for improvement relating to 
# the NEC Materials provided by the Licensee or any Representative without charge 
# or limitation ('Feedback'). The Licensee hereby assigns (or shall procure the 
# assignment of) all Intellectual Property Rights in the Feedback with full title 
# guarantee (including by way of present assignment of future Intellectual 
# Property Rights) to NEC at the time such Feedback is first provided to NEC.

# 5.4	The Licensee acknowledges that the Software may collect information 
# about its use of the NEC Materials under these Terms. NEC may use this 
# information to provide and/or improve its services and products. 

# 5.5	If the Licensee (including any Representatives) institutes any claim or 
# other proceedings against NEC or any other entity alleging that any NEC 
# Materials (including any outputs or results), or any part thereof, constitute 
# an infringement of any third party rights, including any Intellectual Property 
# Rights, then any rights granted to the Licensee under these Terms shall 
# immediately terminate.  

# 5.6	The Licensee shall indemnify NEC from and against any losses, claims, 
# damages, liability, costs (including legal and other professional fees) and 
# expenses incurred by NEC as a result of or in connection with any third party 
# action, demand or claim relating to use of the Software and the Documentation 
# if such use is against these Terms or to any transmission, receipt, copying, 
# installation, use, possession or other utilisation of any Derivative Work.


# 6.	Limitation of liability
# 6.1	To the extent permitted by law, NEC shall not be liable to the Licensee 
# (and/or its Representatives) under these Terms for any consequential, indirect 
# or special losses, any loss of profit or revenue; destruction, loss of use or 
# corruption of data; loss or corruption of software or systems; loss or damage 
# to equipment; loss of opportunity; and/or harm to reputation or loss of 
# goodwill.

# 6.2	Subject to clause 6.1 and to the extent permitted by law, NEC's 
# aggregate liability to the Licensee (and/or its Representatives) under these 
# Terms shall not exceed €500.

# 6.3	The rights and remedies provided under these Terms are in addition to, 
# and not exclusive of, any rights or remedies provided by law.


# 7.	Term and termination

# 7.1	These Terms shall commence upon the sooner of the Licensee's: (i) 
# acceptance of these Terms; or (ii) access to or download of any of the NEC 
# Materials, and will continue in full force and effect until terminated in 
# accordance with the provisions of these Terms.

# 7.2	NEC may terminate these Terms with immediate effect without notice if: 
# (a)	the Licensee (including any Representatives) is in breach of any 
# provision of these Terms; 
# (b)	the Licensee takes or has taken against it (other than in relation to a 
# solvent restructuring) any step or action towards its entering bankruptcy, 
# administration, provisional liquidation or any composition or arrangement with 
# its creditors, or it entering into a procedure in any jurisdiction with a 
# similar effect to a procedure listed above; or 
# (c)	the Licensee undergoes a change in beneficial ownership of more than 
# 50% of the issued share capital of the company or a change in the legal power 
# to direct or cause the direction of the general management of the company. 

# 7.3	Upon termination of these Terms for any reason:
# (a)	all rights granted by NEC under these Terms shall immediately cease; 
# (b)	the Licensee shall (and shall ensure that its Representatives shall) 
# cease all use of the NEC Materials;
# (c)	the Licensee shall (and shall procure that each Representatives shall) 
# destroy and delete or, if requested by NEC, return any copies of the Software 
# and/or the Documentation in its possession or control (or in the possession or 
# control of any Representative); and
# (d)	any provision of these Terms that expressly or by implication is 
# intended to continue in force on or after termination or expiry of these Terms 
# shall remain in full force and effect.


# 8.	General

# 8.1	Assignment. The Licensee shall not assign, transfer, mortgage, charge, 
# subcontract, delegate, declare a trust over or deal in any other manner with 
# any of its rights and obligations under these Terms without the prior written 
# consent of NEC. NEC may at any time assign, mortgage, charge, delegate, declare 
# a trust over or deal in any other manner with any or all of its rights under 
# these Terms.

# 8.2	Variation. No variation of these Terms shall be effective unless it is 
# in writing and signed by the parties (or their authorised representatives).

# 8.3	Entire agreement. These Terms constitute the entire agreement between 
# NEC and the Licensee and supersedes and extinguishes all previous agreements 
# and understandings between them, whether written or oral, relating to its 
# subject matter.

# 8.4	No partnership or agency. NEC and the Licensee are independent and are 
# not partners or principal and agent and these Terms does not establish any 
# joint venture, trust, fiduciary or other relationship between them, other than 
# the contractual relationship expressly provided for in it. Neither NEC or the 
# Licensee shall have, nor shall represent that it has, any authority to make any 
# commitments on the other's behalf.

# 8.5	Severance. If any provision of these Terms (or part of any provision) 
# is or becomes illegal, invalid or unenforceable, the legality, validity and 
# enforceability of any other provision of these Terms shall not be affected.

# 8.6	Waiver. A waiver of any right or remedy under these Terms or by any 
# applicable law is only effective if given in writing and shall not be deemed a 
# waiver of any subsequent right or remedy. A failure or delay to exercise any 
# right or remedy provided under these Terms or by law shall not constitute a 
# waiver of that or any other right or remedy, nor shall it prevent or restrict 
# any further exercise of that or any other right or remedy. No single or partial 
# exercise of any right or remedy provided under these Terms or by any applicable 
# law shall prevent or restrict the further exercise of that or any other right 
# or remedy.

# 8.7	Third party rights. Nothing in these Terms confers or purports to 
# confer on any third party any right to enforce any provision of these Terms.

# 8.8	Further assurance. The Licensee (at its own cost) shall, and shall use 
# all reasonable endeavours to procure that any necessary third party shall, 
# promptly execute and deliver such documents and perform such acts as may 
# reasonably be required for the purpose of giving full effect to these Terms.

# 8.9	Governing law and jurisdiction. These Terms and any dispute or claim 
# (including non-contractual disputes or claims) arising out of or in connection 
# with it or its subject matter or formation shall be governed by and construed 
# in accordance with the law of England and Wales. Any dispute or claim arising 
# out of, or in connection with these Terms or its subject matter or formation 
# (including non-contractual disputes or claims) shall be subject to the 
# exclusive jurisdiction of the courts of England and Wales. 


# 9.	Definitions and interpretation
# In these Terms the following words and expressions shall have the following 
# meanings:

# 9.1	"Academic Use" means the use by accredited educational or research 
# institutions for non-commercial purposes, including academic research and/or 
# teaching. 

# 9.2	"Documentation" means description and specification of the Software, or 
# the relevant instructions as to how to use the Software, or other technical 
# manuals or documentation for the Software as made available by NEC from time to 
# time.

# 9.3	"Intellectual Property Rights" means any and all copyright, rights in 
# inventions, patents, know-how, trade secrets, trade marks and trade names, 
# service marks, design rights, rights in get-up, database rights and rights in 
# data, semiconductor chip topography rights, utility models, domain names and 
# all similar rights and, in each case: (a) whether registered or not; (b) 
# including any applications to protect or register such rights; (c) including 
# all renewals and extensions of such rights or applications; (d) whether vested, 
# contingent or future; and (e) wherever existing.

# 9.4	"Licensee" means the legal entity accessing or downloading the Software 
# under these Terms.

# 9.5	"NEC" means NEC Laboratories Europe GmbH, a company incorporated under 
# the laws of Germany with registration number HRB 728558 (VAT No.: DE313703076), 
# being established at Kurfuersten-Anlage 36, 69115 Heidelberg, Germany.

# 9.6	"NEC Software Library" means the software library as available at 
# https://github.com/nec-research/DIMOS.

# 9.7	"Open Source Software" means software which is included or combined 
# with the Software and which is provided to NEC under terms and conditions other 
# than those set out under these Terms, including any ‘open source’ software 
# falling within the Open Source Definition issued by the Open Source Initiative 
# (www.opensource.org/docs/osd) and/or any ‘free software’ as defined by the Free 
# Software Foundation (www.gnu.org/philosophy/free-sw.html).

# 9.8	"Representatives" means, as applicable, the employees, contractors, 
# officers, directors, agents, students of the Licensee and/or any other 
# representatives acting on the Licensee's behalf.

# 9.9	"Software" means the applicable software accessed or downloaded from 
# the NEC Software Library.

# 9.10	Clause and paragraph headings shall not affect the interpretation of 
# these Terms.

# 9.11	A reference to legislation or a legislative provision is a reference to 
# it as amended, extended or re-enacted from time to time, and shall include all 
# subordinate legislation made from time to time under that legislation.

# 9.12	The provisions in these Terms shall apply to the exclusion of any other 
# terms that the Licensee seeks to impose or incorporate, or which are implied by 
# law, trade custom, practice or course of dealing.

# 9.13	Any words following the terms including, include, in particular, for 
# example or any similar expression shall be interpreted as illustrative and 
# shall not limit the sense of the words preceding those terms.

# 9.14	These Terms are drafted in the English language. Any notice or other 
# communication given under or in connection with these Terms shall be in 
# English. All other documents provided under or in connection with these Terms 
# shall be in English, or accompanied by a certified English translation. The 
# English language version of these Terms and any notice, communication or other 
# document relating to these Terms shall prevail over any translation and any 
# version in any other language.



"""
This module contains classes for calculating various energy terms in molecular dynamics simulations.

The module includes classes for:
- Nonbonded interactions (Lennard-Jones and electrostatics) with and without cutoffs
- Bonded interactions (bonds, angles, torsions)
- Corrections (dispersion correction)
- CMAP corrections

Each class provides methods to calculate energies based on atomic positions and parameters.
"""

import torch
import math
from warnings import warn

from dimos.utils import get_distances_edge_list, get_distance_vectors, get_dihedral_angle
from dimos.splines import TwoDimensionalSpline
from dimos.ewald import Ewald, PME
from dimos import constants

# Potential performance improvements:
# - Add code that checks if neighborlist is changed, otherwise use old aa/bb/charge tensors?
# - Save from the start the sqrt of epsilon and 0.5*sigma. This avoids some computations!
# - 1-4 distance do not need to be calculated twice either...!

#### Nonbonded interactions with Cutoff ####

class CommonNonBonded():
    """Base class for nonbonded interactions."""
    
    def update_box(self, box):
        """Update the simulation box dimensions.
        
        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        self.box = box


class NonbondedLennardJonesCG(CommonNonBonded):
    """Class for coarse-grained Lennard-Jones nonbonded interactions.

    This class implements Lennard-Jones interactions for coarse-grained molecular dynamics simulations.
    It allows specifying which particle pairs should interact, making it suitable for mixed 
    all-atom/coarse-grained simulations or specialized coarse-grained force fields.

    Parameters
    ----------
    num_atoms : int
        Total number of atoms/particles in the system
    sigmas : torch.Tensor
        Sigma parameters (σ) for Lennard-Jones potential
    epsilons : torch.Tensor
        Epsilon parameters (ε) for Lennard-Jones potential
    cutoff : float 
        Distance beyond which interactions are ignored
    switch_distance : float
        Distance at which to start switching function
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system
    applies_to : torch.Tensor, optional
        Nx2 tensor specifying which particle pairs should interact. If None, all pairs interact.

    Attributes
    ----------
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    cutoff : float
        Interaction cutoff distance
    lj_energy_contrib : LennardJones
        Lennard-Jones energy calculator
    need_filter : bool
        Whether to filter interactions based on applies_to
    filter_applies_to : torch.Tensor
        Boolean mask for allowed interactions
    """

    def __init__(
            self,
            num_atoms,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            cutoff: float,
            switch_distance: float,
            periodic: bool,
            box: torch.Tensor,
            applies_to=None):
        """Initialize coarse-grained Lennard-Jones interactions.

        Parameters
        ----------
        num_atoms : int
            Number of atoms in the system
        sigmas : torch.Tensor
            Sigma values for the Lennard-Jones potential
        epsilons : torch.Tensor  
            Epsilon values for the Lennard-Jones potential
        cutoff : float
            Cutoff distance for interactions
        switch_distance : float
            Distance at which switching function starts
        periodic : bool
            Whether system is periodic
        box : torch.Tensor
            Box dimensions
        applies_to : torch.Tensor, optional
            Specify which particle pairs this force applies to
        """
        self.periodic = periodic
        self.box = box
        self.cutoff = cutoff

        self.lj_energy_contrib = LennardJones(sigmas, epsilons, cutoff, switch_distance, 0.0, None, periodic, box)

        if applies_to is not None:
            self.need_filter = True
            self.filter_applies_to = torch.ones((num_atoms, num_atoms), dtype=torch.bool)
            applies_to = applies_to.T
            assert applies_to.size(0) == 2, "It appears applies_to has the wrong shape"
            self.filter_applies_to[applies_to[0], applies_to[1]] = False
            self.filter_applies_to[applies_to[1], applies_to[0]] = False
        else:
            self.need_filter = False

    def calc_energy(self, pos: torch.Tensor, neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate the Lennard-Jones energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        neighborlist : torch.Tensor
            Neighbor list for nonbonded interactions

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy
        """
        if self.need_filter:
            mask_exclusions = self.filter_applies_to[neighborlist[0], neighborlist[1]]
            neighborlist = neighborlist.T[~mask_exclusions].T

        #print("NBLJ", torch.prod(self.box).item())
        distance_matrix = get_distances_edge_list(
            pos, neighborlist, self.periodic, self.box)
        within_cutoff = distance_matrix <= self.cutoff

        # this is needed, because neighborlist includes skin
        distance_matrix_cut = torch.masked_select(distance_matrix, within_cutoff)
        inverse_distance_cut = 1 / distance_matrix_cut

        lj_energy = self.lj_energy_contrib.calc_energy(
            pos, inverse_distance_cut, distance_matrix_cut, neighborlist[:, within_cutoff])

        return lj_energy
    
    def update_box(self, box):
        """Update the simulation box dimensions.
        
        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        super().update_box(box)
        self.lj_energy_contrib.update_box(box)


class NonbondedCutoffCommon(CommonNonBonded):
    """Base class for nonbonded interactions with cutoff.

    This class provides common functionality for nonbonded interactions using a distance cutoff.
    It handles both Lennard-Jones and electrostatic interactions, with support for 1-4 interactions
    and switching functions.

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for Lennard-Jones potential
    epsilons : torch.Tensor
        Epsilon parameters (ε) for Lennard-Jones potential
    sigmas_adjust : torch.Tensor
        Adjusted sigma parameters for 1-4 interactions
    epsilons_adjust : torch.Tensor
        Adjusted epsilon parameters for 1-4 interactions
    adjust_list : torch.Tensor
        List of atom pairs with 1-4 interactions to adjust
    cutoff : float
        Distance beyond which interactions are ignored
    switch_distance : float
        Distance at which to start switching function
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    dihedral_exclusions : torch.Tensor
        Pairs of atoms with 1-4 interactions
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    cutoff : float
        Interaction cutoff distance
    lj_energy_contrib : LennardJones or LennardJonesExplicitOneFour
        Lennard-Jones energy calculator
    electrostatics_energy_contrib : None
        Placeholder for electrostatics calculator
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            sigmas_adjust,
            epsilons_adjust,
            adjust_list,
            cutoff: float,
            switch_distance: float,
            scnb: torch.Tensor,
            dihedral_exclusions: torch.Tensor,
            periodic: bool,
            box: torch.Tensor):
        """Initialize nonbonded interactions with cutoff.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for Lennard-Jones potential
        epsilons : torch.Tensor
            Epsilon values for Lennard-Jones potential
        sigmas_adjust : torch.Tensor
            Adjusted sigma values for 1-4 interactions
        epsilons_adjust : torch.Tensor
            Adjusted epsilon values for 1-4 interactions  
        adjust_list : torch.Tensor
            List of 1-4 interactions to adjust
        cutoff : float
            Cutoff distance
        switch_distance : float
            Distance to start switching function
        scnb : torch.Tensor
            1-4 interaction scaling factor
        dihedral_exclusions : torch.Tensor
            Dihedral exclusion list
        periodic : bool
            Whether system is periodic
        box : torch.Tensor
            Box dimensions
        """
        self.periodic = periodic
        self.box = box
        self.cutoff = cutoff

        if sigmas_adjust.size(0) > 0:
            self.lj_energy_contrib = LennardJonesExplicitOneFour(
                sigmas, epsilons, sigmas_adjust, epsilons_adjust, adjust_list, cutoff, switch_distance, scnb, dihedral_exclusions, periodic, box)
        else:
            self.lj_energy_contrib = LennardJones(
                sigmas, epsilons, cutoff, switch_distance, scnb, dihedral_exclusions, periodic, box)

        self.electrostatics_energy_contrib = None

    def calc_energy(self, pos: torch.Tensor, neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate total nonbonded energy.

        Computes both Lennard-Jones and electrostatic energies for all pairs within the cutoff.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        neighborlist : torch.Tensor
            Neighbor list containing pairs within cutoff + skin distance

        Returns
        -------
        torch.Tensor
            Total nonbonded energy (Lennard-Jones + electrostatics)
        """
        #print("NBCUTCOMM", torch.prod(self.box).item())
        distance_matrix = get_distances_edge_list(
            pos, neighborlist, self.periodic, self.box)
        within_cutoff = distance_matrix <= self.cutoff
        neighborlist_within_cutoff = neighborlist[:, within_cutoff]
        distance_matrix_cut = torch.masked_select(distance_matrix, within_cutoff)

        inverse_distance_cut = 1 / distance_matrix_cut

        lj_energy = self.lj_energy_contrib.calc_energy(
            pos, inverse_distance_cut, distance_matrix_cut, neighborlist_within_cutoff)

        electrostatics_energy = self.electrostatics_energy_contrib.calc_energy(
            pos, inverse_distance_cut, distance_matrix_cut, neighborlist_within_cutoff)

        return lj_energy + electrostatics_energy
    
    def update_box(self, box):
        """Update the simulation box dimensions.
        
        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        super().update_box(box)
        self.lj_energy_contrib.update_box(box)


class NonbondedInteractionsCutoff(NonbondedCutoffCommon):
    """Class for nonbonded interactions with simple cutoff.

    This class implements nonbonded interactions (Lennard-Jones and electrostatics) using a simple
    distance cutoff. Beyond the cutoff distance, interactions are ignored. For electrostatics,
    a reaction field correction is applied to approximate the effect of the solvent beyond the cutoff.

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for Lennard-Jones potential
    epsilons : torch.Tensor
        Epsilon parameters (ε) for Lennard-Jones potential 
    sigmas_adjust : torch.Tensor
        Adjusted sigma parameters for 1-4 Lennard-Jones interactions
    epsilons_adjust : torch.Tensor
        Adjusted epsilon parameters for 1-4 Lennard-Jones interactions
    adjust_list : torch.Tensor
        List of atom pairs with 1-4 interactions to adjust
    charges : torch.Tensor
        Atomic partial charges
    cutoff : float
        Distance beyond which interactions are ignored
    switch_distance : float
        Distance at which to start switching function for Lennard-Jones
    solvent_dielectric : float
        Dielectric constant of the solvent beyond the cutoff
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    scee : torch.Tensor
        Scaling factor for 1-4 electrostatic interactions
    dihedral_exclusions : torch.Tensor
        Pairs of atoms with 1-4 interactions
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            sigmas_adjust,
            epsilons_adjust,
            adjust_list,
            charges: torch.Tensor,
            cutoff: float,
            switch_distance: float,
            solvent_dielectric: float,
            scnb: torch.Tensor,
            scee: torch.Tensor,
            dihedral_exclusions: torch.Tensor,
            periodic: bool,
            box: torch.Tensor) -> None:
        """Initialize nonbonded interactions with cutoff.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for Lennard-Jones potential
        epsilons : torch.Tensor
            Epsilon values for Lennard-Jones potential
        sigmas_adjust : torch.Tensor
            Adjusted sigma values for 1-4 interactions
        epsilons_adjust : torch.Tensor
            Adjusted epsilon values for 1-4 interactions
        adjust_list : torch.Tensor
            List of 1-4 interactions to adjust
        charges : torch.Tensor
            Atomic charges
        cutoff : float
            Cutoff distance
        switch_distance : float
            Distance to start switching function
        solvent_dielectric : float
            Dielectric constant of solvent
        scnb : torch.Tensor
            1-4 vdW interaction scaling factor
        scee : torch.Tensor
            1-4 electrostatic interaction scaling factor
        dihedral_exclusions : torch.Tensor
            Dihedral exclusion list
        periodic : bool
            Whether system is periodic
        box : torch.Tensor
            Box dimensions
        """
        super().__init__(sigmas, epsilons, sigmas_adjust, epsilons_adjust, adjust_list, cutoff, switch_distance, scnb, dihedral_exclusions, periodic, box)

        self.electrostatics_energy_contrib = ElectrostaticsCutoff(
            charges, solvent_dielectric, cutoff, scee, dihedral_exclusions, periodic, box)

    def __str__(self):
        """Return name of potential.

        Returns
        -------
        str
            Name of potential ('NonbondedCutoff')
        """
        return "NonbondedCutoff"
    
    def update_box(self, box):
        """Update the simulation box dimensions.
        
        Updates box vectors for both Lennard-Jones and electrostatic calculations.
        
        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        super().update_box(box)
        self.electrostatics_energy_contrib.update_box(box)


class NonbondedInteractionsEwald(NonbondedCutoffCommon):
    """Class for nonbonded interactions with Ewald summation.

    This class implements nonbonded interactions using Ewald summation for long-range electrostatics
    and a cutoff for Lennard-Jones. The Ewald method splits electrostatic interactions into short-range
    direct space and long-range reciprocal space contributions. Two variants are supported:
    standard Ewald summation and Particle Mesh Ewald (PME).

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for Lennard-Jones potential
    epsilons : torch.Tensor
        Epsilon parameters (ε) for Lennard-Jones potential
    sigmas_adjust : torch.Tensor
        Adjusted sigma parameters for 1-4 Lennard-Jones interactions
    epsilons_adjust : torch.Tensor
        Adjusted epsilon parameters for 1-4 Lennard-Jones interactions
    adjust_list : torch.Tensor
        List of atom pairs with 1-4 interactions to adjust
    charges : torch.Tensor
        Atomic partial charges
    cutoff : float
        Real-space cutoff distance
    switch_distance : float
        Distance at which to start switching function for Lennard-Jones
    tolerance : float
        Error tolerance for Ewald summation
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    scee : torch.Tensor
        Scaling factor for 1-4 electrostatic interactions
    all_exclusions : torch.Tensor
        All excluded atom pairs (1-2, 1-3, and other exclusions)
    dihedral_exclusions : torch.Tensor
        Pairs of atoms with 1-4 interactions
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system
    method : str, optional
        Ewald summation method to use ('PME' or 'Ewald'), defaults to 'PME'
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            sigmas_adjust,
            epsilons_adjust,
            adjust_list,
            charges: torch.Tensor,
            cutoff: float,
            switch_distance: float,
            tolerance: float,
            scnb: torch.Tensor,
            scee: torch.Tensor,
            all_exclusions: torch.Tensor,
            dihedral_exclusions: torch.Tensor,
            periodic: bool,
            box: torch.Tensor,
            method="PME") -> None:
        """Initialize nonbonded interactions with Ewald summation.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for Lennard-Jones potential
        epsilons : torch.Tensor
            Epsilon values for Lennard-Jones potential
        sigmas_adjust : torch.Tensor
            Adjusted sigma values for 1-4 interactions
        epsilons_adjust : torch.Tensor
            Adjusted epsilon values for 1-4 interactions
        adjust_list : torch.Tensor
            List of 1-4 interactions to adjust
        charges : torch.Tensor
            Atomic charges
        cutoff : float
            Real-space cutoff distance
        switch_distance : float
            Distance to start switching function
        tolerance : float
            Ewald summation error tolerance
        scnb : torch.Tensor
            1-4 vdW interaction scaling factor
        scee : torch.Tensor
            1-4 electrostatic interaction scaling factor
        all_exclusions : torch.Tensor
            List of all exclusions
        dihedral_exclusions : torch.Tensor
            Dihedral exclusion list
        periodic : bool
            Whether system is periodic
        box : torch.Tensor
            Box dimensions
        method : str, optional
            Ewald summation method ('PME' or 'Ewald'), by default 'PME'
        """
        super().__init__(sigmas, epsilons, sigmas_adjust, epsilons_adjust, adjust_list, cutoff, switch_distance, scnb, dihedral_exclusions, periodic, box)

        match method:
            case "Ewald":
                self.electrostatics_energy_contrib = Ewald(
                    charges, tolerance, cutoff, scee, all_exclusions, dihedral_exclusions, periodic, box)
            case "PME":
                self.electrostatics_energy_contrib = PME(
                    charges, tolerance, cutoff, scee, all_exclusions, dihedral_exclusions, periodic, box)

    def __str__(self):
        """Return name of potential.

        Returns
        -------
        str
            Name of potential ('NonbondedEwald')
        """
        return "NonbondedEwald"
    
    def update_box(self, box):
        """Update the simulation box dimensions.
        
        Updates box vectors for both Lennard-Jones and electrostatic calculations.
        
        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        super().update_box(box)
        self.electrostatics_energy_contrib.update_box(box)


class LennardJonesExplicitOneFour(CommonNonBonded):
    """Class for Lennard-Jones potential with explicit 1-4 interactions.
    
    This class implements the Lennard-Jones potential with explicit handling of 1-4 interactions:
    E = 4ε[(σ/r)¹² - (σ/r)⁶] * S(r)
    where:
    - ε is the well depth
    - σ is the distance at which the potential is zero 
    - r is the distance between atoms
    - S(r) is an optional switching function that smoothly takes the potential to zero

    The class handles both regular pairwise interactions and explicit 1-4 interactions between atoms
    separated by exactly three bonds, using separate σ and ε parameters for the 1-4 pairs.

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for regular interactions
    epsilons : torch.Tensor  
        Epsilon parameters (ε) for regular interactions
    sigmas_adjust : torch.Tensor
        Adjusted sigma parameters for 1-4 interactions
    epsilons_adjust : torch.Tensor
        Adjusted epsilon parameters for 1-4 interactions
    adjust_list : torch.Tensor
        List of atom pairs with 1-4 interactions to adjust
    cutoff : float
        Cutoff distance beyond which interactions are ignored
    switch_distance : float
        Distance at which to start applying switching function (None for no switching)
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    exclusions_one_four : torch.Tensor
        Pairs of atoms with 1-4 interactions
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    sigmas : torch.Tensor
        Sigma values for regular interactions
    epsilons : torch.Tensor
        Epsilon values for regular interactions
    cutoff : float
        Interaction cutoff distance
    switch_dist : float
        Switching function start distance
    scnb : torch.Tensor
        1-4 interaction scaling factor
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    exclusions_one_four : torch.Tensor
        1-4 interaction pairs
    aa_one_four : torch.Tensor
        Precomputed r¹² coefficients for 1-4 pairs
    bb_one_four : torch.Tensor
        Precomputed r⁶ coefficients for 1-4 pairs
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            sigmas_adjust,
            epsilons_adjust,
            adjust_list,
            cutoff: float,
            switch_distance: float,
            scnb: torch.Tensor,
            exclusions_one_four: torch.Tensor,
            periodic: bool,
            box: torch.Tensor):
        """Initialize Lennard-Jones potential with explicit 1-4 interactions.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for regular Lennard-Jones interactions
        epsilons : torch.Tensor
            Epsilon values for regular Lennard-Jones interactions
        sigmas_adjust : torch.Tensor
            Adjusted sigma values for 1-4 interactions
        epsilons_adjust : torch.Tensor
            Adjusted epsilon values for 1-4 interactions
        adjust_list : torch.Tensor
            List of 1-4 interactions to adjust
        cutoff : float
            Cutoff distance beyond which interactions are ignored
        switch_distance : float
            Distance at which to start switching function (None for no switching)
        scnb : torch.Tensor
            1-4 interaction scaling factor
        exclusions_one_four : torch.Tensor
            1-4 exclusion list
        periodic : bool
            Whether system is periodic
        box : torch.Tensor
            Box dimensions for periodic system
        """
        self.sigmas = sigmas
        self.epsilons = epsilons
        self.cutoff = cutoff
        self.switch_dist = switch_distance
        self.scnb = scnb

        self.periodic = periodic
        self.box = box

        self.exclusions_one_four = adjust_list

        self.aa_one_four = 4.0 * epsilons_adjust * sigmas_adjust * sigmas_adjust
        self.bb_one_four = 4.0 * epsilons_adjust * sigmas_adjust

    def __str__(self):
        """Return name of potential.

        Returns
        -------
        str
            Name of potential ("LennardJonesExplicit14")
        """
        return "LennardJonesExplicit14"

    def lj_energy(
            self,
            inverse_dist: torch.Tensor,
            distance_matrix_cut: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate regular Lennard-Jones energy.

        Computes E = 4ε[(σ/r)¹² - (σ/r)⁶] * S(r) for all non-excluded atom pairs,
        where S(r) is an optional switching function.

        Parameters
        ----------
        inverse_dist : torch.Tensor
            1/r for each atom pair within cutoff
        distance_matrix_cut : torch.Tensor
            Distance matrix r for pairs within cutoff
        neighborlist : torch.Tensor
            Indices of interacting atom pairs within cutoff

        Returns
        -------
        torch.Tensor
            Total regular Lennard-Jones energy
        """
        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        epsilon_pairs = torch.sqrt(self.epsilons[neighborlist[0]] * self.epsilons[neighborlist[1]])
        sigma_pairs_six = (0.5 * (self.sigmas[neighborlist[0]] + self.sigmas[neighborlist[1]]))**6

        aa = 4.0 * epsilon_pairs * sigma_pairs_six * sigma_pairs_six
        bb = 4.0 * epsilon_pairs * sigma_pairs_six

        interaction_strength = aa * rinv12 - bb * rinv6

        if self.switch_dist is not None:
            mask = distance_matrix_cut > self.switch_dist
            t = (distance_matrix_cut[mask] - self.switch_dist) / \
                (self.cutoff - self.switch_dist)
            switch_val = 1 + t * t * t * (-10 + t * (15 - t * 6))
            interaction_strength[mask] = interaction_strength[mask] * switch_val
        return torch.sum(interaction_strength)

    def lj_energy_contribution_cut_one_four(self, pos: torch.Tensor) -> torch.Tensor:
        """Calculate Lennard-Jones energy contribution from 1-4 interactions.

        Computes scaled 1-4 interactions between atoms separated by exactly three bonds
        using adjusted σ and ε parameters. The energy is divided by the scaling factor scnb.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total 1-4 Lennard-Jones energy contribution
        """
        distance_matrix = get_distances_edge_list(
            pos, self.exclusions_one_four, self.periodic, self.box)
        mask_from_cutoff = [distance_matrix <= self.cutoff]
        distance_matrix = distance_matrix[mask_from_cutoff]
        inverse_dist = 1 / distance_matrix

        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        interaction_strength = self.aa_one_four[mask_from_cutoff] * rinv12 - self.bb_one_four[mask_from_cutoff] * rinv6

        return torch.sum(interaction_strength) / self.scnb

    def calc_energy(
            self,
            pos: torch.Tensor,
            inverse_distance_cut: torch.Tensor,
            distance_matrix: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate total Lennard-Jones energy including regular and 1-4 interactions.

        Combines regular pairwise interactions and scaled 1-4 interactions with adjusted
        parameters to get the total Lennard-Jones energy of the system.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        inverse_distance_cut : torch.Tensor
            1/r for pairs within cutoff
        distance_matrix : torch.Tensor
            Distance matrix r for pairs within cutoff
        neighborlist : torch.Tensor
            Indices of interacting atom pairs within cutoff

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy including both regular and 1-4 interactions
        """
        lj_energy = self.lj_energy(
            inverse_distance_cut, distance_matrix, neighborlist)
        if self.exclusions_one_four.size(0) > 0:
            lj_energy_one_four = self.lj_energy_contribution_cut_one_four(pos)
        else:
            lj_energy_one_four = 0.0

        return lj_energy + lj_energy_one_four


class LennardJones(CommonNonBonded):
    """Class for standard Lennard-Jones potential with cutoff and switching function.

    This class implements the Lennard-Jones potential with a distance cutoff and optional switching function:
    E = 4ε[(σ/r)¹² - (σ/r)⁶] * S(r)
    where:
    - ε is the well depth
    - σ is the distance at which the potential is zero
    - r is the distance between atoms
    - S(r) is an optional switching function that smoothly takes the potential to zero

    The class handles both regular pairwise interactions and scaled 1-4 interactions between atoms
    separated by exactly three bonds.

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for each atom
    epsilons : torch.Tensor
        Epsilon parameters (ε) for each atom
    cutoff : float
        Cutoff distance beyond which interactions are ignored
    switch_distance : float
        Distance at which to start applying switching function (None for no switching)
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    exclusions_one_four : torch.Tensor
        Pairs of atoms with 1-4 interactions
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    sigmas : torch.Tensor
        Sigma values for each atom
    epsilons : torch.Tensor
        Epsilon values for each atom
    cutoff : float
        Interaction cutoff distance
    switch_dist : float
        Switching function start distance
    scnb : torch.Tensor
        1-4 interaction scaling factor
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    exclusions_one_four : torch.Tensor
        1-4 interaction pairs
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            cutoff: float,
            switch_distance: float,
            scnb: torch.Tensor,
            exclusions_one_four: torch.Tensor,
            periodic: bool,
            box: torch.Tensor):
        """Initialize Lennard-Jones potential.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for Lennard-Jones potential
        epsilons : torch.Tensor
            Epsilon values for Lennard-Jones potential
        cutoff : float
            Cutoff distance for interactions
        switch_distance : float
            Distance at which to start switching function
        scnb : torch.Tensor
            Scaling factor for 1-4 interactions
        exclusions_one_four : torch.Tensor
            List of 1-4 interaction pairs
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box vectors for periodic system
        """
        self.sigmas = sigmas
        self.epsilons = epsilons
        self.cutoff = cutoff
        self.switch_dist = switch_distance
        self.scnb = scnb

        self.periodic = periodic
        self.box = box

        self.exclusions_one_four = exclusions_one_four

    def __str__(self):
        """Return name of potential.

        Returns
        -------
        str
            Name of potential
        """
        return "LennardJones"

    def lj_energy(
            self,
            inverse_dist: torch.Tensor,
            distance_matrix_cut: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate Lennard-Jones energy for regular pairwise interactions.

        Computes E = Σᵢⱼ 4εᵢⱼ[(σᵢⱼ/rᵢⱼ)¹² - (σᵢⱼ/rᵢⱼ)⁶] * S(r) where S(r) is an optional
        switching function.

        Parameters
        ----------
        inverse_dist : torch.Tensor
            1/r for each atom pair within cutoff
        distance_matrix_cut : torch.Tensor
            Distances r for each pair within cutoff
        neighborlist : torch.Tensor
            Indices of interacting atom pairs

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy
        """
        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        epsilon_pairs = torch.sqrt(self.epsilons[neighborlist[0]] * self.epsilons[neighborlist[1]])
        sigma_pairs_six = (0.5 * (self.sigmas[neighborlist[0]] + self.sigmas[neighborlist[1]]))**6

        bb = 4.0 * epsilon_pairs * sigma_pairs_six
        aa = bb * sigma_pairs_six

        interaction_strength = aa * rinv12 - bb * rinv6

        if self.switch_dist is not None:
            t = (distance_matrix_cut - self.switch_dist) / (self.cutoff - self.switch_dist)
            switch_val = torch.where(
                t > 0,
                1 + t * t * t * (-10 + t * (15 - t * 6)),
                torch.ones_like(t)
            )
            interaction_strength = interaction_strength * switch_val

        return torch.sum(interaction_strength)

    def lj_energy_contribution_cut_one_four(self, pos: torch.Tensor) -> torch.Tensor:
        """Calculate Lennard-Jones energy contribution from 1-4 interactions.

        Computes scaled 1-4 interactions between atoms separated by exactly three bonds.
        The energy is divided by the scaling factor scnb.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total 1-4 Lennard-Jones energy
        """
        distance_matrix = get_distances_edge_list(
            pos, self.exclusions_one_four, self.periodic, self.box)
        mask_from_cutoff = [distance_matrix <= self.cutoff]
        distance_matrix = distance_matrix[mask_from_cutoff]
        inverse_dist = 1 / distance_matrix

        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        epsilon_pairs = torch.sqrt(
            self.epsilons[self.exclusions_one_four[0]] * self.epsilons[self.exclusions_one_four[1]])
        sigma_pairs_six = (
            0.5 * (self.sigmas[self.exclusions_one_four[0]] + self.sigmas[self.exclusions_one_four[1]]))**6

        aa = 4 * epsilon_pairs * sigma_pairs_six * sigma_pairs_six
        bb = 4 * epsilon_pairs * sigma_pairs_six

        interaction_strength = aa[mask_from_cutoff] * \
            rinv12 - bb[mask_from_cutoff] * rinv6

        return torch.sum(interaction_strength) / self.scnb

    def calc_energy(
            self,
            pos: torch.Tensor,
            inverse_distance_cut: torch.Tensor,
            distance_matrix: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """Calculate total Lennard-Jones energy including regular and 1-4 interactions.

        Combines regular pairwise interactions and scaled 1-4 interactions to get the total
        Lennard-Jones energy of the system.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        inverse_distance_cut : torch.Tensor
            1/r for pairs within cutoff
        distance_matrix : torch.Tensor
            Distances r for pairs within cutoff
        neighborlist : torch.Tensor
            Indices of interacting atom pairs

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy including both regular and 1-4 interactions
        """
        lj_energy = self.lj_energy(
            inverse_distance_cut, distance_matrix, neighborlist)
        if self.exclusions_one_four is not None and self.exclusions_one_four.size(0) > 0:
            lj_energy_one_four = self.lj_energy_contribution_cut_one_four(pos)
        else:
            lj_energy_one_four = 0.0

        return lj_energy + lj_energy_one_four

class ElectrostaticsCutoff(CommonNonBonded):
    """
    A class to represent electrostatic interactions with a reaction field cutoff.

    This class implements electrostatic interactions between charged particles using a reaction field 
    approximation with a cutoff. The reaction field approach models the solvent beyond the cutoff as 
    a dielectric continuum.

    The potential takes the form:
    E = (q₁q₂/4πε₀) * (1/r + k_rf*r² - c_rf)
    where:
    - q₁,q₂ are the charges
    - r is the distance between particles
    - k_rf and c_rf are reaction field parameters based on the cutoff and solvent dielectric
    
    The class handles both regular pairwise interactions and scaled 1-4 interactions between atoms
    separated by exactly three bonds.

    Parameters
    ----------
    charges : torch.Tensor
        Atomic partial charges
    solvent_dielectric : float
        Dielectric constant of the solvent beyond the cutoff
    cutoff : float
        Cutoff distance for direct interactions
    scee : torch.Tensor
        Scaling factor for 1-4 electrostatic interactions (typically 1.2 or 2.0)
    exlusions_one_four_no_improper : torch.Tensor
        Pairs of atoms with 1-4 interactions, excluding improper dihedrals
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    charges : torch.Tensor
        Atomic partial charges
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    cutoff : float
        Interaction cutoff distance
    exlusions_one_four_no_improper : torch.Tensor
        1-4 interaction pairs
    one_four_charges : torch.Tensor
        Precomputed scaled charge products for 1-4 interactions
    denom : float
        Denominator term for reaction field parameters
    krf : float
        Reaction field k parameter
    crf : float
        Reaction field c parameter
    """

    def __init__(
            self,
            charges: torch.Tensor,
            solvent_dielectric: float,
            cutoff: float,
            scee: torch.Tensor,
            exlusions_one_four_no_improper: torch.Tensor,
            periodic: bool,
            box: torch.Tensor) -> None:
        """
        Initialize electrostatic interactions with reaction field cutoff.

        Parameters
        ----------
        charges : torch.Tensor
            Atomic partial charges
        solvent_dielectric : float
            Dielectric constant of the solvent beyond the cutoff
        cutoff : float
            Cutoff distance for direct interactions
        scee : torch.Tensor
            Scaling factor for 1-4 electrostatic interactions
        exlusions_one_four_no_improper : torch.Tensor
            Pairs of atoms with 1-4 interactions, excluding improper dihedrals
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box vectors for periodic system
        """
        self.charges = charges
        self.periodic = periodic
        self.box = box
        self.cutoff = cutoff
        self.exlusions_one_four_no_improper = exlusions_one_four_no_improper

        if self.exlusions_one_four_no_improper.size(0) > 0:
            self.one_four_charges = self.charges[self.exlusions_one_four_no_improper[0]] * self.charges[self.exlusions_one_four_no_improper[1]] / scee
        else:
            self.one_four_charges = torch.tensor([])

        self.denom = (2.0 * solvent_dielectric) + 1.0
        self.krf = (1.0 / self.cutoff**3) * (solvent_dielectric - 1.0) / self.denom
        self.crf = (1.0 / self.cutoff) * (3.0 * solvent_dielectric) / self.denom

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential ('RFA' for Reaction Field Approximation)
        """
        return "RFA"

    def electrostatic_energy_contribution(
            self,
            inverse_dist: torch.Tensor,
            distance_matrix: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """
        Calculate the regular electrostatic energy contribution.

        Computes the reaction field electrostatic energy between all non-excluded atom pairs using:
        E = (q₁q₂/4πε₀) * (1/r + k_rf*r² - c_rf)

        Parameters
        ----------
        inverse_dist : torch.Tensor
            1/r for each atom pair within cutoff
        distance_matrix : torch.Tensor
            Distance matrix for pairs within cutoff
        neighborlist : torch.Tensor
            List of interacting atom pairs within cutoff

        Returns
        -------
        torch.Tensor
            Total regular electrostatic energy
        """
        dist2 = distance_matrix * distance_matrix
        pot = self.charges[neighborlist[0]] * self.charges[neighborlist[1]] * (inverse_dist + self.krf * dist2 - self.crf)
        return torch.sum(pot) * constants.ONE_BY_4_PI_EPSILON_0

    def electrostatic_energy_contribution_one_four(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the 1-4 electrostatic energy contribution.

        Computes scaled electrostatic interactions between atoms separated by exactly
        three bonds using:
        E = (q₁q₂)/(4πε₀r * SCEE)
        where SCEE is the 1-4 electrostatic scaling factor.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total 1-4 electrostatic energy
        """
        distance_matrix = get_distances_edge_list(pos, self.exlusions_one_four_no_improper, self.periodic, self.box)
        return torch.sum(self.one_four_charges / distance_matrix) * constants.ONE_BY_4_PI_EPSILON_0

    def calc_energy(
            self,
            pos: torch.Tensor,
            inverse_distance_cut: torch.Tensor,
            distance_matrix_cut: torch.Tensor,
            neighborlist: torch.Tensor) -> torch.Tensor:
        """
        Calculate the total electrostatic energy.

        Combines regular pairwise electrostatic interactions using reaction field approach
        and scaled 1-4 interactions to get the total electrostatic energy of the system.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        inverse_distance_cut : torch.Tensor
            1/r for pairs within cutoff
        distance_matrix_cut : torch.Tensor
            Distance matrix for pairs within cutoff
        neighborlist : torch.Tensor
            List of interacting atom pairs within cutoff

        Returns
        -------
        torch.Tensor
            Total electrostatic energy including both regular and 1-4 interactions
        """
        electrostatic_energy = self.electrostatic_energy_contribution(inverse_distance_cut, distance_matrix_cut, neighborlist)
        if self.one_four_charges.size(0) > 0:
            electrostatic_energy_one_four = self.electrostatic_energy_contribution_one_four(pos)
        else:
            electrostatic_energy_one_four = 0.0

        return electrostatic_energy + electrostatic_energy_one_four

#### Nonbonded interactions no cutoff ####


class NonbondedInteractionsNoCutoff(CommonNonBonded):
    """
    A class to represent nonbonded interactions without a cutoff.

    Attributes
    ----------
    periodic : bool
        Whether the system is periodic.
    box : torch.Tensor
        Dimensions of the simulation box.
    upper_triangle : torch.Tensor
        Upper triangle indices for the interaction matrix.
    lj_energy_contrib : LennardJonesNoCutoff
        Lennard-Jones energy contribution.
    electrostatics_energy_contrib : ElectrostaticsNoCutoff
        Electrostatics energy contribution.
    """

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            sigmas_adjust,
            epsilons_adjust,
            adjust_list,
            charges: torch.Tensor,
            scnb: torch.Tensor,
            scee: torch.Tensor,
            exclusions_one_four: torch.Tensor,
            all_exclusions,
            periodic: bool,
            box: torch.Tensor) -> None:
        """
        Initialize the NonbondedInteractionsNoCutoff class.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for the Lennard-Jones potential.
        epsilons : torch.Tensor
            Epsilon values for the Lennard-Jones potential.
        charges : torch.Tensor
            Charges of the atoms.
        scnb : torch.Tensor
            Scaling factor for 1-4 interactions.
        scee : torch.Tensor
            Scaling factor for electrostatic interactions.
        exclusions_one_four : torch.Tensor
            Exclusions for 1-4 interactions.
        all_exclusions : list
            List of all exclusions.
        periodic : bool
            Whether the system is periodic.
        box : torch.Tensor
            Dimensions of the simulation box.
        """
        self.periodic = periodic
        self.box = box

        self.upper_triangle = torch.triu_indices(sigmas.size(0), sigmas.size(0), offset=1)

        self.lj_energy_contrib = LennardJonesNoCutoff(
            sigmas, epsilons, scnb, exclusions_one_four, all_exclusions, self.upper_triangle, periodic, box)
        self.electrostatics_energy_contrib = ElectrostaticsNoCutoff(
            charges, scee, exclusions_one_four, all_exclusions, self.upper_triangle, periodic, box)

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "NonbondedNoCutoff"

    def calc_energy(self, pos: torch.Tensor, neighborlist=None) -> torch.Tensor:
        """
        Calculate the total nonbonded energy without a cutoff.

        Parameters
        ----------
        pos : torch.Tensor
            positions of the atoms.
        neighborlist : torch.Tensor, optional
            Neighbor list for nonbonded interactions (default is None).

        Returns
        -------
        torch.Tensor
            Total nonbonded energy of the system.
        """
        #print("NBNOCUT", torch.prod(self.box).item())
        distance_matrix = get_distances_edge_list(pos, self.upper_triangle, self.periodic, self.box)
        inverse_distance = 1.0 / distance_matrix

        lj_energy = self.lj_energy_contrib.calc_energy(
            pos, inverse_distance)
        electrostatics_energy = self.electrostatics_energy_contrib.calc_energy(
            pos, inverse_distance)

        return lj_energy + electrostatics_energy
    
    def update_box(self, box):
        super().update_box(box)
        self.lj_energy_contrib.update_box(box)
        self.electrostatics_energy_contrib.update_box(box)


class LennardJonesNoCutoff(CommonNonBonded):
    """
    A class to represent Lennard-Jones interactions without a cutoff.

    This class implements the Lennard-Jones potential without any distance cutoff:
    E = 4ε[(σ/r)¹² - (σ/r)⁶]
    where ε is the well depth, σ is the distance at which the potential is zero,
    and r is the distance between atoms.

    The class handles both regular pairwise interactions and scaled 1-4 interactions
    between atoms separated by exactly three bonds. Exclusions are applied to avoid
    calculating interactions between bonded atoms.

    Parameters
    ----------
    sigmas : torch.Tensor
        Sigma parameters (σ) for each atom
    epsilons : torch.Tensor  
        Epsilon parameters (ε) for each atom
    scnb : torch.Tensor
        Scaling factor for 1-4 Lennard-Jones interactions
    exclusions_one_four : torch.Tensor
        Pairs of atoms with 1-4 interactions
    all_exclusions : torch.Tensor
        All excluded atom pairs
    upper_triangle : torch.Tensor
        Upper triangle indices for interaction matrix
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    sigmas : torch.Tensor
        Sigma values for each atom
    epsilons : torch.Tensor
        Epsilon values for each atom
    scnb : torch.Tensor
        1-4 interaction scaling factor
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    exclusions_one_four : torch.Tensor
        1-4 interaction pairs
    aa : torch.Tensor
        Precomputed r¹² coefficients 
    bb : torch.Tensor
        Precomputed r⁶ coefficients
    aa_exclusions_one_four : torch.Tensor
        Precomputed r¹² coefficients for 1-4 pairs
    bb_exclusions_one_four : torch.Tensor
        Precomputed r⁶ coefficients for 1-4 pairs
    """

    def get_aa_and_bb_tensors(self, list_of_interactions):
        """
        Compute the r¹² and r⁶ coefficients for a list of atom pairs.

        For each pair i,j this calculates:
        aa = 4 * √(εᵢεⱼ) * [(σᵢ + σⱼ)/2]¹²
        bb = 4 * √(εᵢεⱼ) * [(σᵢ + σⱼ)/2]⁶

        Parameters
        ----------
        list_of_interactions : torch.Tensor
            Nx2 tensor of atom pair indices

        Returns
        -------
        tuple of torch.Tensor
            aa and bb coefficients for the pairs
        """
        epsilon_pairs = torch.sqrt(self.epsilons[list_of_interactions[0]] * self.epsilons[list_of_interactions[1]])
        sigma_pairs_six = (0.5 * (self.sigmas[list_of_interactions[0]] + self.sigmas[list_of_interactions[1]]))**6

        aa = 4.0 * epsilon_pairs * sigma_pairs_six * sigma_pairs_six
        bb = 4.0 * epsilon_pairs * sigma_pairs_six
        return aa, bb

    def __init__(
            self,
            sigmas: torch.Tensor,
            epsilons: torch.Tensor,
            scnb: torch.Tensor,
            exclusions_one_four: torch.Tensor,
            all_exclusions: torch.Tensor,
            upper_triangle: torch.Tensor,
            periodic: bool,
            box: torch.Tensor) -> None:
        """
        Initialize the LennardJonesNoCutoff class.

        Parameters
        ----------
        sigmas : torch.Tensor
            Sigma values for each atom
        epsilons : torch.Tensor
            Epsilon values for each atom
        scnb : torch.Tensor
            Scaling factor for 1-4 interactions
        exclusions_one_four : torch.Tensor
            Pairs of atoms with 1-4 interactions
        all_exclusions : torch.Tensor
            All excluded atom pairs
        upper_triangle : torch.Tensor
            Upper triangle indices for interaction matrix
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box vectors for periodic system
        """
        self.sigmas = sigmas
        self.epsilons = epsilons
        self.scnb = scnb

        self.periodic = periodic
        self.box = box

        self.exclusions_one_four = exclusions_one_four

        sigmas_pairs = 0.5 * (self.sigmas[None] + self.sigmas[:, None])
        epsilons_pairs = torch.sqrt(torch.matmul(self.epsilons[:, None], self.epsilons[:, None].T))

        aa = 4 * epsilons_pairs * sigmas_pairs**12
        bb = 4 * epsilons_pairs * sigmas_pairs**6

        aa[all_exclusions[0], all_exclusions[1]] = 0.0
        aa[all_exclusions[1], all_exclusions[0]] = 0.0

        bb[all_exclusions[0], all_exclusions[1]] = 0.0
        bb[all_exclusions[1], all_exclusions[0]] = 0.0

        self.aa = aa[upper_triangle[0], upper_triangle[1]]
        self.bb = bb[upper_triangle[0], upper_triangle[1]]

        self.aa_exclusions_one_four, self.bb_exclusions_one_four = self.get_aa_and_bb_tensors(exclusions_one_four)

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "LennardJonesNoCutoff"

    def lj_energy(self, inverse_dist: torch.Tensor) -> torch.Tensor:
        """
        Calculate the Lennard-Jones energy for regular pairwise interactions.

        Computes E = Σᵢⱼ 4εᵢⱼ[(σᵢⱼ/rᵢⱼ)¹² - (σᵢⱼ/rᵢⱼ)⁶] using precomputed coefficients.

        Parameters
        ----------
        inverse_dist : torch.Tensor
            1/r for each atom pair

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy
        """
        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        interaction_strength = self.aa * rinv12 - self.bb * rinv6
        return torch.sum(interaction_strength)

    def lj_contribution_from_exclusion_one_four(self, pos):
        """
        Calculate the Lennard-Jones energy from 1-4 interactions.

        Computes scaled 1-4 interactions between atoms separated by exactly three bonds.
        The energy is divided by the scaling factor scnb.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total 1-4 Lennard-Jones energy
        """
        distance_matrix = get_distances_edge_list(pos, self.exclusions_one_four, self.periodic, self.box)
        inverse_dist = 1 / distance_matrix

        rinv2 = inverse_dist * inverse_dist
        rinv6 = rinv2 * rinv2 * rinv2
        rinv12 = rinv6 * rinv6

        interaction_strength = self.aa_exclusions_one_four * rinv12 - self.bb_exclusions_one_four * rinv6
        return torch.sum(interaction_strength) / self.scnb

    def calc_energy(self, pos: torch.Tensor, inverse_distance) -> torch.Tensor:
        """
        Calculate the total Lennard-Jones energy.

        Combines regular pairwise interactions and scaled 1-4 interactions.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        inverse_distance : torch.Tensor
            1/r for each atom pair

        Returns
        -------
        torch.Tensor
            Total Lennard-Jones energy including both regular and 1-4 interactions
        """
        lj_energy = self.lj_energy(inverse_distance)
        lj_energy_one_four = self.lj_contribution_from_exclusion_one_four(pos)
        return lj_energy + lj_energy_one_four

class ElectrostaticsNoCutoff(CommonNonBonded):
    """
    A class to represent electrostatic interactions without a cutoff distance.

    This class implements Coulomb's law for electrostatic interactions between charged particles:
    E = (q₁q₂)/(4πε₀r)
    where q₁,q₂ are the charges, ε₀ is the vacuum permittivity, and r is the distance between particles.

    The class handles both regular pairwise interactions and scaled 1-4 interactions between atoms
    separated by exactly three bonds. Exclusions are applied to avoid calculating interactions
    between bonded atoms.

    Parameters
    ----------
    charges : torch.Tensor
        Atomic partial charges
    scee : torch.Tensor
        Scaling factor for 1-4 electrostatic interactions (typically 1.2 or 2.0)
    dihedral_exclusion : torch.Tensor
        Pairs of atoms with 1-4 interactions
    all_exclusions : torch.Tensor
        All excluded atom pairs (1-2, 1-3, and other exclusions)
    upper_triangle : torch.Tensor
        Upper triangle indices for interaction matrix
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors for periodic system

    Attributes
    ----------
    charges : torch.Tensor
        Atomic partial charges
    dihedral_exclusion : torch.Tensor
        1-4 interaction pairs
    all_exclusions : torch.Tensor
        All excluded pairs
    periodic : bool
        Whether system is periodic
    box : torch.Tensor
        Box vectors
    charges_2d : torch.Tensor
        Precomputed charge products for regular interactions
    one_four_charges : torch.Tensor
        Precomputed scaled charge products for 1-4 interactions
    """

    def __init__(
            self,
            charges: torch.Tensor,
            scee: torch.Tensor,
            dihedral_exclusion: torch.Tensor,
            all_exclusions: torch.Tensor,
            upper_triangle: torch.Tensor,
            periodic: bool,
            box: torch.Tensor) -> None:
        """
        Initialize the ElectrostaticsNoCutoff class.

        Parameters
        ----------
        charges : torch.Tensor
            Atomic partial charges
        scee : torch.Tensor
            Scaling factor for 1-4 electrostatic interactions
        dihedral_exclusion : torch.Tensor
            Pairs of atoms with 1-4 interactions
        all_exclusions : torch.Tensor
            All excluded atom pairs
        upper_triangle : torch.Tensor
            Upper triangle indices for interaction matrix
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box vectors for periodic system
        """
        self.charges = charges
        self.dihedral_exclusion = dihedral_exclusion
        self.all_exclusions = all_exclusions
        self.periodic = periodic
        self.box = box

        charges_2d = torch.matmul(self.charges.unsqueeze(-1), self.charges.unsqueeze(-1).T)

        charges_2d[all_exclusions[1], all_exclusions[0]] = 0.0
        charges_2d[all_exclusions[0], all_exclusions[1]] = 0.0

        self.charges_2d = charges_2d[upper_triangle[0], upper_triangle[1]]
        self.one_four_charges = self.charges[dihedral_exclusion[0]] * self.charges[dihedral_exclusion[1]] / scee

    def __str__(self):
        """
        Return a string representation of the potential.

        Returns
        -------
        str
            The name of the potential
        """
        return "ElectrostaticsNoCutoff"

    def electrostatic_energy_contribution(self, inverse_dist: torch.Tensor) -> torch.Tensor:
        """
        Calculate the regular electrostatic energy contribution.

        Computes the Coulomb energy between all non-excluded atom pairs using:
        E = (q₁q₂)/(4πε₀r)

        Parameters
        ----------
        inverse_dist : torch.Tensor
            1/r for each atom pair

        Returns
        -------
        torch.Tensor
            Total regular electrostatic energy
        """
        return torch.sum(self.charges_2d * inverse_dist) * constants.ONE_BY_4_PI_EPSILON_0

    def electrostatic_energy_contribution_one_four(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the 1-4 electrostatic energy contribution.

        Computes scaled electrostatic interactions between atoms separated by exactly
        three bonds using:
        E = (q₁q₂)/(4πε₀r * SCEE)
        where SCEE is the 1-4 electrostatic scaling factor.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total 1-4 electrostatic energy
        """
        distance_matrix = get_distances_edge_list(pos, self.dihedral_exclusion, self.periodic, self.box)
        electrostatic_exlusion_one_four = torch.sum(self.one_four_charges / distance_matrix) * constants.ONE_BY_4_PI_EPSILON_0

        return electrostatic_exlusion_one_four

    def calc_energy(self, pos: torch.Tensor, inverse_distance: torch.Tensor) -> torch.Tensor:
        """
        Calculate the total electrostatic energy.

        Combines regular pairwise electrostatic interactions and scaled 1-4 interactions
        to get the total electrostatic energy of the system.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions
        inverse_distance : torch.Tensor
            1/r for each atom pair

        Returns
        -------
        torch.Tensor
            Total electrostatic energy including both regular and 1-4 interactions
        """
        electrostatic_energy = self.electrostatic_energy_contribution(inverse_distance)
        electrostatic_energy_one_four = self.electrostatic_energy_contribution_one_four(pos)

        return electrostatic_energy + electrostatic_energy_one_four

### Bonded interactions ###

class CommonBonded():
    """
    Base class for bonded interactions.

    This class provides common functionality for all bonded interaction classes,
    such as updating the simulation box dimensions.
    """
    def update_box(self, box):
        """
        Update the simulation box dimensions.

        Parameters
        ----------
        box : torch.Tensor
            New box dimensions
        """
        self.box = box


class CmapCorrection(CommonBonded):
    """
    Class for CMAP (Correction Map) energy corrections.

    This class implements CMAP corrections which are used to improve the accuracy of 
    protein backbone energetics in force fields. It uses 2D spline interpolation to
    calculate correction energies based on phi/psi dihedral angles.

    Parameters
    ----------
    function_values : torch.Tensor
        Grid of CMAP energy correction values
    resolution : int
        Resolution of the CMAP grid (number of points per dimension)
    cmap_atom_list : torch.Tensor
        List of 5 atoms defining the two dihedrals for each CMAP term
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors if using periodic boundaries

    Notes
    -----
    This is an experimental feature that requires further testing and validation.
    """

    def __init__(self, function_values, resolution, cmap_atom_list, periodic, box):
        warn("CMAP corrections are currently an very early stage experimental feature. While it should work somewhat correctly, it has not been thoroughly tested. Please be careful when using it and compare to established implementations.", stacklevel=2)
        # TODO: How do we find out whether the tabulated values are expecting 0--2pi or -pi--pi?
        bin_ranges = torch.linspace(0.0, 2.0 * torch.pi, resolution)
        self.spline_object = TwoDimensionalSpline()

        # TODO: Function values may need to be transposed...
        self.spline_object.initialize_spline(
            bin_ranges, bin_ranges, function_values.reshape(
                resolution, resolution), periodic=True, use_tridiagonal=False)

        # TODO: I believe this is the correct definition of the involved atoms, but need to make sure...
        self.edge_list_1_0 = torch.stack((cmap_atom_list[:, 0], cmap_atom_list[:, 1]))
        self.edge_list_2_0 = torch.stack((cmap_atom_list[:, 1], cmap_atom_list[:, 2]))
        self.edge_list_3_0 = torch.stack((cmap_atom_list[:, 2], cmap_atom_list[:, 3]))

        self.edge_list_1_1 = torch.stack((cmap_atom_list[:, 1], cmap_atom_list[:, 2]))
        self.edge_list_2_1 = torch.stack((cmap_atom_list[:, 2], cmap_atom_list[:, 3]))
        self.edge_list_3_1 = torch.stack((cmap_atom_list[:, 3], cmap_atom_list[:, 4]))

        self.periodic = periodic
        self.box = box

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "CmapCorrection"

    def calc_energy(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the CMAP correction energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            CMAP correction energy
        """
        phi = get_dihedral_angle(pos, self.edge_list_1_0, self.edge_list_2_0, self.edge_list_3_0, self.periodic, self.box)
        psi = get_dihedral_angle(pos, self.edge_list_1_1, self.edge_list_2_1, self.edge_list_3_1, self.periodic, self.box)

        energy = 0.0
        for si, hi in zip(psi, phi):
            energy = energy + self.spline_object.evaluate_spline(si, hi)

        return energy


class HarmonicBond(CommonBonded):
    """
    Class for harmonic bond interactions.

    This class implements harmonic bond potentials of the form:
    E = k(r - r0)^2
    where k is the force constant, r is the bond length, and r0 is the equilibrium length.

    Parameters
    ----------
    bond_list : torch.Tensor
        List of atom pairs defining bonds
    bond_parameters : torch.Tensor
        Parameters for each bond [k, r0]
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors if using periodic boundaries
    """

    def __init__(self, bond_list: torch.Tensor, bond_parameters: torch.Tensor, periodic: bool, box: torch.Tensor) -> None:
        self.bond_list = bond_list
        self.bond_parameters = bond_parameters
        self.periodic = periodic
        self.box = box

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "HarmonicBond"

    def calc_energy(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the harmonic bond energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions

        Returns
        -------
        torch.Tensor
            Total harmonic bond energy
        """
        distances = get_distances_edge_list(pos, self.bond_list, self.periodic, self.box)
        return torch.sum(self.bond_parameters[:, 0] * (distances - self.bond_parameters[:, 1])**2)

class HarmonicAngle(CommonBonded):
    """
    A class to represent harmonic angle interactions.

    This class implements harmonic angle potentials of the form:
    E = k(θ - θ₀)²
    where k is the force constant, θ is the angle between three atoms, and θ₀ is the 
    equilibrium angle.

    Parameters
    ----------
    angle_list : torch.Tensor
        List of atom triplets defining angles (shape: N x 3)
    angle_parameters : torch.Tensor
        Parameters for each angle [k, θ₀] where k is the force constant and θ₀ is the
        equilibrium angle in radians
    periodic : bool
        Whether to use periodic boundary conditions
    box : torch.Tensor
        Box vectors if using periodic boundaries

    Attributes
    ----------
    angle_parameters : torch.Tensor
        Parameters for each angle [k, θ₀]
    periodic : bool
        Whether periodic boundary conditions are used
    box : torch.Tensor
        Box vectors for periodic systems
    edge_list_10 : torch.Tensor
        Edge list connecting atoms 1-2 of each angle
    edge_list_12 : torch.Tensor
        Edge list connecting atoms 2-3 of each angle
    """

    def __init__(self, angle_list: torch.Tensor, angle_parameters: torch.Tensor, periodic: bool, box: torch.Tensor) -> None:
        """
        Initialize the HarmonicAngle class.

        Parameters
        ----------
        angle_list : torch.Tensor
            List of atom triplets defining angles (shape: N x 3)
        angle_parameters : torch.Tensor
            Parameters for each angle [k, θ₀]
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box vectors if using periodic boundaries
        """
        self.angle_parameters = angle_parameters
        self.periodic = periodic
        self.box = box
        self.edge_list_10 = torch.stack((angle_list[:, 0], angle_list[:, 1]))
        self.edge_list_12 = torch.stack((angle_list[:, 2], angle_list[:, 1]))

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "HarmonicAngle"

    def calc_energy(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the harmonic angle energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions (shape: N x 3)

        Returns
        -------
        torch.Tensor
            Total harmonic angle energy
        """
        r_10 = get_distance_vectors(pos, self.edge_list_10, self.periodic, self.box)
        r_12 = get_distance_vectors(pos, self.edge_list_12, self.periodic, self.box)

        scalar_product = torch.linalg.vecdot(r_10, r_12, dim=1)

        norm_10 = torch.linalg.vector_norm(r_10, dim=1)
        norm_12 = torch.linalg.vector_norm(r_12, dim=1)

        cos_argument = torch.clamp(scalar_product / (norm_10 * norm_12), -1, 1)
        interaction_angle = torch.acos(cos_argument)

        angle_energy = interaction_angle - self.angle_parameters[:, 1]

        return torch.sum(self.angle_parameters[:, 0] * angle_energy * angle_energy)


class CHARMMTorsion(CommonBonded):
    """
    A class to represent CHARMM-style harmonic torsion angle interactions.

    This class implements a harmonic torsion angle potential of the form:
    E = k(φ - φ₀)²
    where k is the force constant, φ is the torsion angle, and φ₀ is the equilibrium angle.

    Attributes
    ----------
    torsion_parameters : torch.Tensor
        Parameters for the torsions, containing force constants and equilibrium angles
    periodic : bool
        Whether periodic boundary conditions should be used
    box : torch.Tensor
        Box dimensions for periodic systems
    edge_list_1 : torch.Tensor
        Edge list connecting atoms 1-2 of each torsion
    edge_list_2 : torch.Tensor  
        Edge list connecting atoms 2-3 of each torsion
    edge_list_3 : torch.Tensor
        Edge list connecting atoms 3-4 of each torsion
    """

    def __init__(self, torsion_list: torch.Tensor, torsion_parameters: torch.Tensor, periodic: bool, box: torch.Tensor) -> None:
        """
        Initialize the CHARMM torsion potential.

        Parameters
        ----------
        torsion_list : torch.Tensor
            List of atom indices defining each torsion (shape: N x 4)
        torsion_parameters : torch.Tensor
            Parameters for each torsion, containing force constants and equilibrium angles
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box dimensions for periodic systems
        """
        self.torsion_parameters = torsion_parameters
        self.periodic = periodic
        self.box = box
        self.edge_list_1 = torch.stack((torsion_list[:, 0], torsion_list[:, 1]))
        self.edge_list_2 = torch.stack((torsion_list[:, 1], torsion_list[:, 2]))
        self.edge_list_3 = torch.stack((torsion_list[:, 2], torsion_list[:, 3]))

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "CHARMMTorsion"

    def calc_energy(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the CHARMM torsion energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions (shape: N x 3)

        Returns
        -------
        torch.Tensor
            Total torsion energy
        """

        phi = get_dihedral_angle(pos, self.edge_list_1, self.edge_list_2, self.edge_list_3, self.periodic, self.box)

        energy_contrib = self.torsion_parameters[:, 0] * (phi - self.torsion_parameters[:, 1])**2
        return torch.sum(energy_contrib)


class Torsion(CommonBonded):
    """
    A class to represent periodic torsion angle interactions.

    This class implements a periodic torsion angle potential of the form:
    E = k(1 + cos(nφ - δ))
    where k is the force constant, n is the multiplicity, φ is the torsion angle,
    and δ is the phase shift.

    Attributes
    ----------
    torsion_parameters : torch.Tensor
        Parameters for the torsions, containing force constants, multiplicities and phase shifts
    periodic : bool
        Whether periodic boundary conditions should be used
    box : torch.Tensor
        Box dimensions for periodic systems
    edge_list_1 : torch.Tensor
        Edge list connecting atoms 1-2 of each torsion
    edge_list_2 : torch.Tensor
        Edge list connecting atoms 2-3 of each torsion
    edge_list_3 : torch.Tensor
        Edge list connecting atoms 3-4 of each torsion
    """

    def __init__(self, torsion_list: torch.Tensor, torsion_parameters: torch.Tensor, periodic: bool, box: torch.Tensor) -> None:
        """
        Initialize the periodic torsion potential.

        Parameters
        ----------
        torsion_list : torch.Tensor
            List of atom indices defining each torsion (shape: N x 4)
        torsion_parameters : torch.Tensor
            Parameters for each torsion, containing force constants, multiplicities and phase shifts
        periodic : bool
            Whether to use periodic boundary conditions
        box : torch.Tensor
            Box dimensions for periodic systems
        """
        self.torsion_parameters = torsion_parameters
        self.periodic = periodic
        self.box = box
        self.edge_list_1 = torch.stack((torsion_list[:, 0], torsion_list[:, 1]))
        self.edge_list_2 = torch.stack((torsion_list[:, 1], torsion_list[:, 2]))
        self.edge_list_3 = torch.stack((torsion_list[:, 2], torsion_list[:, 3]))

    def __str__(self):
        """
        Return the name of the potential.

        Returns
        -------
        str
            The name of the potential.
        """
        return "Torsion"

    def calc_energy(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Calculate the periodic torsion energy.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions (shape: N x 3)

        Returns
        -------
        torch.Tensor
            Total torsion energy
        """

        phi = get_dihedral_angle(pos, self.edge_list_1, self.edge_list_2, self.edge_list_3, self.periodic, self.box)

        angle_diff = self.torsion_parameters[:, 1] * phi - self.torsion_parameters[:, 2]
        energy_contrib = self.torsion_parameters[:, 0] * (1 + torch.cos(angle_diff))
        return torch.sum(energy_contrib)

### Corrections ###


class DispersionCorrection(CommonBonded):
    """
    A class to calculate long-range dispersion corrections for Lennard-Jones interactions.

    This class implements analytical corrections for the truncation of Lennard-Jones
    interactions beyond a cutoff distance. It accounts for both direct cutoff and
    switched cutoff schemes.

    The correction is derived by integrating the Lennard-Jones potential from the
    cutoff distance to infinity, assuming a uniform distribution of particles.
    For switched cutoffs, it also includes the contribution from the switching
    region.

    Attributes
    ----------
    box : torch.Tensor
        Dimensions of the periodic simulation box
    cutoff : float
        Distance beyond which Lennard-Jones interactions are truncated
    switch_distance : float or None
        Distance at which the switching function begins to be applied.
        If None, no switching is used.
    dispersion_energy : torch.Tensor
        Pre-computed dispersion correction energy term that only needs to be
        scaled by the system volume
    """

    def __init__(self, sigmas, epsilons, cutoff, switch_distance, box):
        """
        Initialize the dispersion correction calculator.

        Parameters
        ----------
        sigmas : torch.Tensor
            Lennard-Jones sigma parameters for each atom type
        epsilons : torch.Tensor
            Lennard-Jones epsilon parameters for each atom type
        cutoff : float
            Distance beyond which Lennard-Jones interactions are truncated
        switch_distance : float or None
            Distance at which the switching function begins.
            If None, no switching is used.
        box : torch.Tensor
            Dimensions of the periodic simulation box
        """
        self.box = box
        self.cutoff = cutoff
        self.switch_distance = switch_distance

        epsilon_ij = (epsilons[:, None] * epsilons[None, :]) ** 0.5
        sigma_ij = (sigmas[:, None] + sigmas[None, :]) / 2.0

        sum_1 = torch.sum(epsilon_ij * sigma_ij ** 12) / (9.0 * self.cutoff ** 9.0)
        sum_2 = torch.sum(epsilon_ij * sigma_ij ** 6) / (3.0 * self.cutoff ** 3.0)
        dispersion_energy = sum_1 - sum_2
        sum_3 = 0.0
        if switch_distance is not None:
            # add the switch part of the dispersion correction
            sum_3 = torch.sum(epsilon_ij * self._eval_switch_integral(sigma_ij))

        self.dispersion_energy = 8.0 * math.pi * (dispersion_energy + sum_3)

    def __str__(self):
        """
        Return a string identifier for this potential.

        Returns
        -------
        str
            Name of the potential
        """
        return "DispersionCorrection"

    def _eval_switch_integral(self, sigma_ij: torch.Tensor) -> torch.Tensor:
        """
        Evaluate the integral of the switching function contribution.

        This method computes the analytical integral of the switching function
        contribution to the dispersion correction. The switching function smoothly
        turns off the potential between the switch distance and the cutoff.

        Parameters
        ----------
        sigma_ij : torch.Tensor
            Combined sigma parameters for each pair of atom types

        Returns
        -------
        torch.Tensor
            Value of the switching function integral for the dispersion correction
        """
        rc = self.cutoff
        rs = self.switch_distance

        # pre-compute constants
        A = 1.0 / (rc - rs)
        A2 = A * A
        A3 = A2 * A

        sig2 = sigma_ij ** 2
        sig6 = sig2 ** 3

        rs2 = rs ** 2
        rs3 = rs2 * rs
        rs4 = rs3 * rs
        rs5 = rs4 * rs
        rs6 = rs5 * rs
        rs9 = rs6 * rs3

        rc2 = rc ** 2
        rc3 = rc2 * rc
        rc4 = rc3 * rc
        rc5 = rc4 * rc
        rc6 = rc5 * rc
        rc9 = rc6 * rc3

        tmp_1 = rs3 * 28.0 * (6.0 * rs2 * A2 + 15.0 * rs * A + 10.0)
        tmp_2 = rs2 * 945.0 * (rs2 * A2 + 2.0 * rs * A + 1.0)
        tmp_3 = rs * 1080.0 * (2.0 * rs2 * A2 + 3.0 * rs * A + 1.0)
        tmp_4 = 420.0 * (6.0 * rs2 * A2 + 6.0 * rs * A + 1.0)
        tmp_5 = 756.0 * (2.0 * rs * A2 + A)
        tmp_6 = 378.0 * A2
        tmp_7 = rs3 * 84.0 * (6.0 * rs2 * A2 + 15.0 * rs * A + 10.0)
        tmp_8 = rs2 * 3780.0 * (rs2 * A2 + 2.0 * rs * A + 1.0)
        tmp_9 = rs * 7560.0 * (2 * rs2 * A2 + 3.0 * rs * A + 1.0)

        # compute sig6 and r6 terms
        tmp_sig6c = sig6 * (tmp_1 - rc * tmp_2 + rc2 * tmp_3 - rc3 * tmp_4 + rc4 * tmp_5 - rc5 * tmp_6)
        tmp_sig6s = sig6 * (tmp_1 - rs * tmp_2 + rs2 * tmp_3 - rs3 * tmp_4 + rs4 * tmp_5 - rs5 * tmp_6)

        tmp_r6c = rc6 * (tmp_7 - rc * tmp_8 + rc2 * tmp_9)
        tmp_r6s = rs6 * (tmp_7 - rs * tmp_8 + rs2 * tmp_9)

        # compute integral value
        integral_value = (tmp_sig6c - tmp_r6c) / (252.0 * rc9) - (tmp_sig6s - tmp_r6s) / (252.0 * rs9)
        integral_value = integral_value - math.log(rc / rs) * 10.0 * (6.0 * rs2 * A2 + 6.0 * rs * A + 1.0)
        integral_value = integral_value + (rc - rs) * 15.0 * (2.0 * rs * A2 + A)
        integral_value = integral_value - (rc2 - rs2) * 3.0 * A2
        return integral_value * sig6 * A3

    def calc_energy(self, pos):
        """
        Calculate the dispersion correction energy.

        The correction energy is pre-computed during initialization and only needs
        to be scaled by the current system volume.

        Parameters
        ----------
        pos : torch.Tensor
            Atomic positions (unused, included for API consistency)

        Returns
        -------
        torch.Tensor
            The dispersion correction energy scaled by system volume
        """
        #print("DISPERS", torch.prod(self.box).item())
        return self.dispersion_energy / torch.prod(self.box)
