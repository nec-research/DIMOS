# NEC Software Library Academic Use Licence Terms (the 'Terms')

# THESE TERMS APPLY TO THE LICENSEE'S USE OF THE "SOFTWARE" AS IDENTIFIED BELOW 
# (INCLUDING ANY PORTION OR ELEMENT OF THE SOFTWARE), INCLUDING ANY UPDATES TO 
# THE SOFTWARE RECEIVED FROM NEC, AND BY DOWNLOADING OR USING THE SOFTWARE (OR 
# RECEIVING ANY UPDATES TO THE SOFTWARE) THE LICENSEE AGREES TO BE BOUND BY THESE 
# TERMS. 

# THESE TERMS ARE A CONTRACTUAL AGREEMENT BETWEEN THE LICENSEE AND NEC. IF THE 
# LICENSEE DOES NOT AGREE TO THESE TERMS, IT CANNOT DOWNLOAD THE SOFTWARE OR USE 
# THE SOFTWARE FOR ANY PURPOSE.


# 1.	Software licence rights for Academic Use

# 1.1	The Licensee is granted a personal, non-exclusive, worldwide, 
# non-transferrable, non-sublicensable, royalty-free and limited licence to use, 
# reproduce, copy, create derivate works of and/or make modifications to the 
# Software solely for Academic Use; and to use and copy the Documentation solely 
# in connection with the rights granted in the foregoing.

# 1.2	The Licensee acknowledges that, unless otherwise expressly agreed in 
# writing by NEC, the licence granted under clause 1.1 does not permit the 
# commercial use of the Software for any purpose, including any distribution or 
# resale of the Software (either directly, or indirectly as part of any package 
# or bundle of software, cloud software or software as a service product), any 
# use in collaborations between academic and commercial entities (including any 
# funding of PhD activities by commercial entities), or any non-commercial use of 
# the Software by a commercial entity.

# 1.3	For the avoidance of doubt, the Licensee is not permitted to use the 
# Software and/or the Documentation under these Terms for any commercial purposes 
# whilst representing that such use is a form of Academic Use. If NEC has the 
# reasonable belief that the Licensee is using the Software and/or the 
# Documentation for any commercial purposes then such use will be deemed a breach 
# of these Terms and NEC may terminate the licence granted under these Terms with 
# immediate effect in accordance with clause 7.2(a).

# 1.4	The Licensee must use the Software and/or the Documentation in 
# accordance with any applicable laws and regulations, including any applicable 
# import and export control laws, associated embargo and sanction rules and 
# regulations relating to the export of software, or materials or products in 
# connection with the export of software. For clarity, the parties acknowledge 
# that the export control laws of United States and the export/import control 
# laws of other countries may govern the use of the Software and/or the 
# Documentation. The Licensee therefore agrees to comply fully with all relevant 
# export laws and regulations, including those of Japan, European Union (and 
# European Union member states), United Kingdom, and the United States, to ensure 
# that the Software and/or the Documentation or any portion thereof is exported, 
# directly or indirectly, in violation of export laws and regulations. This 
# clause will survive the termination or expiration of these Terms.

# 1.5	The Licensee shall ensure that only its Representatives use the 
# Software and that such use is at all times in accordance with these Terms. The 
# Licensee shall procure that each Representative is aware of, and complies with, 
# the obligations and restrictions imposed on the Licensee under these Terms. 

# 1.6	The Licensee shall be liable for the acts and omissions of its 
# Representatives as if they were its own, and shall not provide access to the 
# Software (or permit access by) anyone other than a Representative.

# 1.7	If the Licensee wishes to use the Software, the Documentation and/or 
# any Derivative Works for commercial purposes then it must enter into a separate 
# commercial licence agreement with NEC, on such terms as NEC acting in its sole 
# discretion requires from time to time. For the avoidance of doubt, NEC reserves 
# the right to not enter into any such commercial licence agreement or other 
# arrangements with the Licensee or any third party.


# 2.	Licence rights regarding Derivative Works

# 2.1	If the Licensee develops any derivate works of the Software, any part 
# of the Software and/or any modifications to the Software, either as the result 
# of a pull request received by NEC from the Licensee or a Representative or 
# otherwise (each a 'Derivative Work') or any product or service that uses or 
# incorporates any Derivative Works then:
# (a)	subject to clause 5.1, as between the Licensee and NEC, all 
# Intellectual Property Rights in the Derivative Works belong to and shall remain 
# vested in the Licensee;
# (b)	the Licensee hereby grants to NEC a perpetual, fully paid-up, 
# non-exclusive, royalty-free, transferrable, sublicensable, irrevocable licence 
# to use, copy, modify, reproduce and/or create derivate works of the Derivative 
# Works for any purpose; 
# (c)	the Licensee must provide NEC a copy of the source code of any 
# Derivative Works via its code repository located at https://github.com/nec-research/DIMOS;
# (d)	the Licensee must provide a copy of these Terms with the Derivative 
# Work(s);
# (e)	the Licensee must prominently display "Built using NEC technology" on 
# any related software description, website, user interface, about page, software 
# specification or other technical documentation; and
# (f)	the Licensee must include in any notice text file distributed as part 
# of any Derivate Work: "[Derivate Work] is licensed under the NEC Software 
# Library Academic License. Copyright © 2025 NEC Laboratories Europe GmbH. All 
# Rights Reserved. 

# 2.2	The Licensee is only permitted to use any Derivative Works for Academic 
# Use. The Licensee is not permitted to use any Derivative Works for commercial 
# use, or to permit or otherwise enable any third party to use any Derivative 
# Works for commercial use. Section 1 of the Terms do accordingly apply. 


# 3.	Acceptable use policy

# 3.1	As a condition of use, the Licensee agrees not to use the Software, nor 
# permit it to be used by any Representative or otherwise: 
# (a)	for any purpose that is unlawful under any applicable law or prohibited 
# by these Terms; 
# (b)	to commit any act of fraud or money laundering or otherwise be used in 
# any activities that are deceptive or harmful to others; 
# (c)	to create, store, access, transfer to any third party or otherwise 
# distribute any code or device intended to interfere with, or having the effect 
# of interfering adversely with, the operation of any hardware or software, 
# including any virus, disabling code (including code intended to limit or 
# prevent any use any software or system) or other malicious software (including 
# bugs, worms, logic bombs, malware, trojan horses, ransomware and spyware), or 
# any other material which is unlawful;
# (d)	for the purposes of promoting unsolicited advertising or sending spam, 
# or for the creation or promotion of disinformation;
# (e)	for the purposes of creating, promoting or furthering any defamatory 
# content, including any defamatory statements, images or other media;
# (f)	to simulate communications from any third party service or entity (i.e. 
# phishing communications) in order to collect identity information, 
# authentication credentials, or other information; 
# (g)	in any manner that disrupts the operations, business, equipment, 
# websites or systems of any person or entity (including any denial of service 
# and similar attacks);
# (h)	in any manner that harms or may endanger minors or any other person, or 
# may cause damage or loss to any tangible property or the environment;
# (i)	to gain unauthorised access to or use of any computers, data, systems, 
# accounts or networks of any person;
# (j)	to attempt to circumvent any security controls or mechanisms; 
# (k)	in any manner that engages in or promotes the harassment, abuse, 
# bullying or discrimination of any individuals or groups of individuals; 
# (l)	in any manner that violates, infringes upon, or misappropriates the 
# Intellectual Property Rights or proprietary rights of NEC or any third party; 
# (m)	to sell, publish, rent, lease or otherwise commercialise the Software 
# or any Derivative Work, or assist any third party in relation to the same; or
# (n)	to reverse engineer, decompile or disassemble the Software except and 
# solely to the extent permitted under these Terms.


# 4.	No warranty

# 4.1	The Software and Documentation (including any part thereof and/or any 
# updates provided under these Terms) (together the 'NEC Materials') are provided 
# "as is" and without warranty to the maximum extent permitted by law. To the 
# extent permitted by law, NEC gives no express or implied warranties, 
# guarantees, conditions or obligations under these Terms, including any express 
# or implied terms relating to quality, fitness for any particular purpose, 
# title, non-infringement, or ability to achieve a particular result. 

# 4.2	The Licensee acknowledges that it is solely responsible for determining 
# the appropriateness of using the NEC Materials and assumes any and all risks 
# associated with its use of the NEC Materials, any Derivative Works and/or any 
# other outputs or results relating to any of the foregoing.


# 5.	Intellectual property rights

# 5.1	As between the Licensee and NEC, all rights, including all Intellectual 
# Property Rights, in the NEC Materials belong to and shall remain vested in NEC. 
# Except for the rights expressly granted in these Terms, the Licensee and/or any 
# Representative shall not acquire in any way any title, rights of ownership, or 
# any other Intellectual Property Rights or other rights of any nature in the NEC 
# Materials and no Intellectual Property Rights or other rights are transferred 
# or licensed as a result of these Terms.

# 5.2	The Licensee acknowledges and agrees that certain aspects of the 
# Software provided under these Terms are based on or powered by Open Source 
# Software, either developed by NEC (and which is not based on or derived from 
# Open Source Software licensed to NEC) or derived from, or incorporated into 
# and/or distributed with other Open Source Software licensed to NEC.

# 5.3	NEC may use any feedback and suggestions for improvement relating to 
# the NEC Materials provided by the Licensee or any Representative without charge 
# or limitation ('Feedback'). The Licensee hereby assigns (or shall procure the 
# assignment of) all Intellectual Property Rights in the Feedback with full title 
# guarantee (including by way of present assignment of future Intellectual 
# Property Rights) to NEC at the time such Feedback is first provided to NEC.

# 5.4	The Licensee acknowledges that the Software may collect information 
# about its use of the NEC Materials under these Terms. NEC may use this 
# information to provide and/or improve its services and products. 

# 5.5	If the Licensee (including any Representatives) institutes any claim or 
# other proceedings against NEC or any other entity alleging that any NEC 
# Materials (including any outputs or results), or any part thereof, constitute 
# an infringement of any third party rights, including any Intellectual Property 
# Rights, then any rights granted to the Licensee under these Terms shall 
# immediately terminate.  

# 5.6	The Licensee shall indemnify NEC from and against any losses, claims, 
# damages, liability, costs (including legal and other professional fees) and 
# expenses incurred by NEC as a result of or in connection with any third party 
# action, demand or claim relating to use of the Software and the Documentation 
# if such use is against these Terms or to any transmission, receipt, copying, 
# installation, use, possession or other utilisation of any Derivative Work.


# 6.	Limitation of liability
# 6.1	To the extent permitted by law, NEC shall not be liable to the Licensee 
# (and/or its Representatives) under these Terms for any consequential, indirect 
# or special losses, any loss of profit or revenue; destruction, loss of use or 
# corruption of data; loss or corruption of software or systems; loss or damage 
# to equipment; loss of opportunity; and/or harm to reputation or loss of 
# goodwill.

# 6.2	Subject to clause 6.1 and to the extent permitted by law, NEC's 
# aggregate liability to the Licensee (and/or its Representatives) under these 
# Terms shall not exceed €500.

# 6.3	The rights and remedies provided under these Terms are in addition to, 
# and not exclusive of, any rights or remedies provided by law.


# 7.	Term and termination

# 7.1	These Terms shall commence upon the sooner of the Licensee's: (i) 
# acceptance of these Terms; or (ii) access to or download of any of the NEC 
# Materials, and will continue in full force and effect until terminated in 
# accordance with the provisions of these Terms.

# 7.2	NEC may terminate these Terms with immediate effect without notice if: 
# (a)	the Licensee (including any Representatives) is in breach of any 
# provision of these Terms; 
# (b)	the Licensee takes or has taken against it (other than in relation to a 
# solvent restructuring) any step or action towards its entering bankruptcy, 
# administration, provisional liquidation or any composition or arrangement with 
# its creditors, or it entering into a procedure in any jurisdiction with a 
# similar effect to a procedure listed above; or 
# (c)	the Licensee undergoes a change in beneficial ownership of more than 
# 50% of the issued share capital of the company or a change in the legal power 
# to direct or cause the direction of the general management of the company. 

# 7.3	Upon termination of these Terms for any reason:
# (a)	all rights granted by NEC under these Terms shall immediately cease; 
# (b)	the Licensee shall (and shall ensure that its Representatives shall) 
# cease all use of the NEC Materials;
# (c)	the Licensee shall (and shall procure that each Representatives shall) 
# destroy and delete or, if requested by NEC, return any copies of the Software 
# and/or the Documentation in its possession or control (or in the possession or 
# control of any Representative); and
# (d)	any provision of these Terms that expressly or by implication is 
# intended to continue in force on or after termination or expiry of these Terms 
# shall remain in full force and effect.


# 8.	General

# 8.1	Assignment. The Licensee shall not assign, transfer, mortgage, charge, 
# subcontract, delegate, declare a trust over or deal in any other manner with 
# any of its rights and obligations under these Terms without the prior written 
# consent of NEC. NEC may at any time assign, mortgage, charge, delegate, declare 
# a trust over or deal in any other manner with any or all of its rights under 
# these Terms.

# 8.2	Variation. No variation of these Terms shall be effective unless it is 
# in writing and signed by the parties (or their authorised representatives).

# 8.3	Entire agreement. These Terms constitute the entire agreement between 
# NEC and the Licensee and supersedes and extinguishes all previous agreements 
# and understandings between them, whether written or oral, relating to its 
# subject matter.

# 8.4	No partnership or agency. NEC and the Licensee are independent and are 
# not partners or principal and agent and these Terms does not establish any 
# joint venture, trust, fiduciary or other relationship between them, other than 
# the contractual relationship expressly provided for in it. Neither NEC or the 
# Licensee shall have, nor shall represent that it has, any authority to make any 
# commitments on the other's behalf.

# 8.5	Severance. If any provision of these Terms (or part of any provision) 
# is or becomes illegal, invalid or unenforceable, the legality, validity and 
# enforceability of any other provision of these Terms shall not be affected.

# 8.6	Waiver. A waiver of any right or remedy under these Terms or by any 
# applicable law is only effective if given in writing and shall not be deemed a 
# waiver of any subsequent right or remedy. A failure or delay to exercise any 
# right or remedy provided under these Terms or by law shall not constitute a 
# waiver of that or any other right or remedy, nor shall it prevent or restrict 
# any further exercise of that or any other right or remedy. No single or partial 
# exercise of any right or remedy provided under these Terms or by any applicable 
# law shall prevent or restrict the further exercise of that or any other right 
# or remedy.

# 8.7	Third party rights. Nothing in these Terms confers or purports to 
# confer on any third party any right to enforce any provision of these Terms.

# 8.8	Further assurance. The Licensee (at its own cost) shall, and shall use 
# all reasonable endeavours to procure that any necessary third party shall, 
# promptly execute and deliver such documents and perform such acts as may 
# reasonably be required for the purpose of giving full effect to these Terms.

# 8.9	Governing law and jurisdiction. These Terms and any dispute or claim 
# (including non-contractual disputes or claims) arising out of or in connection 
# with it or its subject matter or formation shall be governed by and construed 
# in accordance with the law of England and Wales. Any dispute or claim arising 
# out of, or in connection with these Terms or its subject matter or formation 
# (including non-contractual disputes or claims) shall be subject to the 
# exclusive jurisdiction of the courts of England and Wales. 


# 9.	Definitions and interpretation
# In these Terms the following words and expressions shall have the following 
# meanings:

# 9.1	"Academic Use" means the use by accredited educational or research 
# institutions for non-commercial purposes, including academic research and/or 
# teaching. 

# 9.2	"Documentation" means description and specification of the Software, or 
# the relevant instructions as to how to use the Software, or other technical 
# manuals or documentation for the Software as made available by NEC from time to 
# time.

# 9.3	"Intellectual Property Rights" means any and all copyright, rights in 
# inventions, patents, know-how, trade secrets, trade marks and trade names, 
# service marks, design rights, rights in get-up, database rights and rights in 
# data, semiconductor chip topography rights, utility models, domain names and 
# all similar rights and, in each case: (a) whether registered or not; (b) 
# including any applications to protect or register such rights; (c) including 
# all renewals and extensions of such rights or applications; (d) whether vested, 
# contingent or future; and (e) wherever existing.

# 9.4	"Licensee" means the legal entity accessing or downloading the Software 
# under these Terms.

# 9.5	"NEC" means NEC Laboratories Europe GmbH, a company incorporated under 
# the laws of Germany with registration number HRB 728558 (VAT No.: DE313703076), 
# being established at Kurfuersten-Anlage 36, 69115 Heidelberg, Germany.

# 9.6	"NEC Software Library" means the software library as available at 
# https://github.com/nec-research/DIMOS.

# 9.7	"Open Source Software" means software which is included or combined 
# with the Software and which is provided to NEC under terms and conditions other 
# than those set out under these Terms, including any ‘open source’ software 
# falling within the Open Source Definition issued by the Open Source Initiative 
# (www.opensource.org/docs/osd) and/or any ‘free software’ as defined by the Free 
# Software Foundation (www.gnu.org/philosophy/free-sw.html).

# 9.8	"Representatives" means, as applicable, the employees, contractors, 
# officers, directors, agents, students of the Licensee and/or any other 
# representatives acting on the Licensee's behalf.

# 9.9	"Software" means the applicable software accessed or downloaded from 
# the NEC Software Library.

# 9.10	Clause and paragraph headings shall not affect the interpretation of 
# these Terms.

# 9.11	A reference to legislation or a legislative provision is a reference to 
# it as amended, extended or re-enacted from time to time, and shall include all 
# subordinate legislation made from time to time under that legislation.

# 9.12	The provisions in these Terms shall apply to the exclusion of any other 
# terms that the Licensee seeks to impose or incorporate, or which are implied by 
# law, trade custom, practice or course of dealing.

# 9.13	Any words following the terms including, include, in particular, for 
# example or any similar expression shall be interpreted as illustrative and 
# shall not limit the sense of the words preceding those terms.

# 9.14	These Terms are drafted in the English language. Any notice or other 
# communication given under or in connection with these Terms shall be in 
# English. All other documents provided under or in connection with these Terms 
# shall be in English, or accompanied by a certified English translation. The 
# English language version of these Terms and any notice, communication or other 
# document relating to these Terms shall prevail over any translation and any 
# version in any other language.



"""
Integrator module.

This module provides various integrators for molecular dynamics simulations,
including velocity Verlet, Langevin dynamics, Brownian dynamics, and various
thermostats. These integrators are used to propagate the system through time
by updating positions and velocities based on forces and constraints.
"""


import torch
import math
from warnings import warn

from dimos.utils import maxwell_boltzmann_distr, kinetic_energy, get_distances_edge_list, periodic_correction
from dimos import constants
from dimos.constraints import PassthroughConstraintHandling

class CommonIntegrator():
    """
    Base class for molecular dynamics integrators.
    
    This abstract class provides common functionality for all integrators,
    including timestep handling, acceleration updates, and tensor detachment
    for memory efficiency.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.

    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    dtype : torch.dtype
        The data type for the integrator.
    a : torch.Tensor or None
        The acceleration tensor.
    constraint_handler : object
        The constraint handler for the system.
    shift : float
        Shift parameter for velocity calculations, used in some integrators.
    """

    def set_timestep(self, timestep):
        """
        Set the timestep for the integrator.
        
        Converts from femtoseconds to internal time units.
        
        Parameters
        ----------
        timestep : float or torch.Tensor
            The timestep in femtoseconds.
            
        Raises
        ------
        AssertionError
            If the timestep is zero or negative.
        """
        self.timestep = timestep / constants.FS_TO_INTERNAL
        assert self.timestep > 0.0, "Timestep cannot be zero or negative"

    def get_timestep(self):
        """
        Get the timestep in femtoseconds.
        
        Returns
        -------
        float
            The timestep in femtoseconds.
        """
        return self.timestep * constants.FS_TO_INTERNAL

    def detach_(self):
        """
        Detach tensors from the computation graph.
        
        This method detaches all tensors returned by get_variables_to_detach()
        from the computation graph to save memory.
        """
        for var in self.get_variables_to_detach():
            var.detach_()

    def __init__(self, timestep, sys, dtype=None):
        """
        Initialize the CommonIntegrator class.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """
        if dtype is None:
            self.dtype = torch.get_default_dtype()
        else:
            self.dtype = dtype

        self.constraint_handler = sys.constraint_handler
        self.set_timestep(timestep)

        self.a = None
        self.shift = 0.0

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration based on forces from the system.
        
        This method must be implemented by subclasses to define how
        accelerations are calculated.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
            
        Raises
        ------
        NotImplementedError
            If the subclass does not implement this method.
        """
        pass

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single integration step.
        
        This method must be implemented by subclasses to define the
        specific integration algorithm.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator for stochastic integrators.

        Returns
        -------
        tuple
            The updated positions and velocities.
            
        Raises
        ------
        NotImplementedError
            If the subclass does not implement this method.
        """
        raise NotImplementedError("Integrators must implement step function)")

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list of tensors to detach from the computation graph.
        """
        return []
    
    def update_box(self, box):
        """
        Update the simulation box dimensions.
        
        This method updates the box dimensions in the constraint handler.
        
        Parameters
        ----------
        box : torch.Tensor
            The new box dimensions.
        """
        self.constraint_handler.update_box(box)

class DummyIntegrator(CommonIntegrator):
    """
    A dummy integrator that does not modify positions or velocities.
    
    This integrator simply returns the input positions and velocities unchanged.
    It can be used for testing or as a placeholder when no integration is needed.
    
    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
    """
    
    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a dummy integration step (no changes).
        
        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator (not used).
            
        Returns
        -------
        tuple
            The unchanged positions and velocities.
        """
        return pos, vel


class Verlet(CommonIntegrator):
    """
    Verlet integrator for molecular dynamics.
    
    This class implements the standard Verlet integration algorithm, which
    updates positions and velocities in a way that conserves energy for
    conservative systems.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    dtype : torch.dtype
        The data type for the integrator.
    shift : float
        Shift parameter for velocity calculations (0.5 * timestep for Verlet).
    a : torch.Tensor
        The acceleration tensor.
    """

    def __init__(self, timestep, sys, dtype=None):
        """
        Initialize the Verlet integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """
        super().__init__(timestep, sys, dtype)
        self.shift = 0.5 * self.timestep

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration based on forces from the system.
        
        This method calculates forces and converts them to accelerations.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the acceleration tensor.
        """
        return [self.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Verlet integration step.
        
        This method implements the Verlet algorithm:
        1. Update velocities using current accelerations
        2. Update positions using updated velocities
        3. Apply constraints to positions
        4. Adjust velocities based on position changes

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator (not used in this integrator).

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        self.update_acceleration(pos, neighborlist, sys)

        vel = vel + self.a * self.timestep

        original_pos = pos.clone()
        pos = pos + vel * self.timestep
        pos_prime = pos.clone()
        self.constraint_handler.apply_constraints(original_pos, pos_prime)

        pos_difference = pos_prime - pos
        if sys.periodic:
            pos_difference = periodic_correction(pos_difference, sys.box)

        vel_prime = pos_difference / self.timestep

        return pos_prime, vel_prime


# class VelocityVerletNonConstraintedDebug(CommonIntegrator):
#     """
#     Velocity Verlet integrator without constraint handling for debugging.
    
#     This class implements the standard velocity Verlet algorithm without applying
#     constraints, which is useful for debugging constraint-related issues.

#     Parameters
#     ----------
#     timestep : float
#         The timestep for the integrator in femtoseconds.
#     sys : object
#         The system object containing information about the molecular system.
#     dtype : torch.dtype, optional
#         The data type for the integrator. If None, the default data type is used.
        
#     Attributes
#     ----------
#     timestep : float
#         The timestep for the integrator in internal time units.
#     dtype : torch.dtype
#         The data type for the integrator.
#     a : torch.Tensor
#         The acceleration tensor.
#     """

#     def __init__(self, timestep, sys, dtype=None):
#         """
#         Initialize the VelocityVerletNonConstraintedDebug integrator.

#         Parameters
#         ----------
#         timestep : float
#             The timestep for the integrator in femtoseconds.
#         sys : object
#             The system object containing information about the molecular system.
#         dtype : torch.dtype, optional
#             The data type for the integrator. If None, the default data type is used.
#         """
#         super().__init__(timestep, sys, dtype)

#     def update_acceleration(self, pos, neighborlist, sys):
#         """
#         Update the acceleration based on forces from the system.
        
#         This method calculates forces and converts them to accelerations.

#         Parameters
#         ----------
#         pos : torch.Tensor
#             The positions of the particles.
#         neighborlist : torch.Tensor or None
#             The neighbor list for efficient force calculation.
#         sys : object
#             The system object containing force field information.
#         """
#         self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

#     def get_variables_to_detach(self):
#         """
#         Get the variables that should be detached from the computation graph.
        
#         Returns
#         -------
#         list
#             A list containing the acceleration tensor.
#         """
#         return [self.a]

#     def step(self, pos, vel, neighborlist, sys, generator=None):
#         """
#         Perform a single velocity Verlet integration step without constraints.
        
#         This method implements the velocity Verlet algorithm:
#         1. Update velocities by half a timestep
#         2. Update positions using updated velocities
#         3. Update accelerations based on new positions
#         4. Update velocities for the second half timestep

#         Parameters
#         ----------
#         pos : torch.Tensor
#             The positions of the particles.
#         vel : torch.Tensor
#             The velocities of the particles.
#         neighborlist : torch.Tensor or None
#             The neighbor list for efficient force calculation.
#         sys : object
#             The system object containing force field information.
#         generator : torch.Generator, optional
#             The random number generator (not used in this integrator).

#         Returns
#         -------
#         tuple
#             The updated positions and velocities.
#         """
#         vel = vel + 0.5 * self.a * self.timestep

#         pos = pos + vel * self.timestep

#         #self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)
#         self.update_acceleration(pos, neighborlist, sys)

#         vel = vel + 0.5 * self.a * self.timestep

#         return pos, vel


class VelocityVerlet(CommonIntegrator):
    """
    Velocity Verlet integrator with constraint handling.
    
    This class implements the velocity Verlet algorithm with proper constraint
    handling for both positions and velocities, making it suitable for
    simulations with bond constraints or other geometric constraints.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    dtype : torch.dtype
        The data type for the integrator.
    a : torch.Tensor
        The acceleration tensor.
    """

    def __init__(self, timestep, sys, dtype=None):
        """
        Initialize the VelocityVerlet integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """
        super().__init__(timestep, sys, dtype)

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration based on forces from the system.
        
        This method calculates forces and converts them to accelerations.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the acceleration tensor.
        """
        return [self.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single velocity Verlet integration step with constraint handling.
        
        This method implements the velocity Verlet algorithm with constraints:
        1. Update velocities by half a timestep
        2. Update positions using updated velocities
        3. Apply position constraints
        4. Update accelerations based on new positions
        5. Update velocities for the second half timestep
        6. Apply velocity constraints

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator (not used in this integrator).

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        vel = vel + 0.5 * self.a * self.timestep

        original_pos = pos.clone()
        pos = pos + vel * self.timestep
        pos_prime = pos.clone()
        self.constraint_handler.apply_constraints(original_pos, pos_prime)

        self.update_acceleration(pos_prime, neighborlist, sys)

        pos_difference = pos_prime - pos
        if sys.periodic:
            #pos_difference = pos_difference - sys.box * torch.floor(pos_difference / sys.box + 0.5)
            pos_difference = periodic_correction(pos_difference, sys.box)

        vel = vel + 0.5 * self.a * self.timestep + pos_difference / self.timestep

        vel_prime = vel.clone()
        self.constraint_handler.apply_velocity_constraints(pos_prime, vel_prime)

        return pos_prime, vel_prime

class BrownianDynamics(CommonIntegrator):
    """
    Brownian dynamics integrator.
    
    This class implements the Brownian dynamics algorithm, which is suitable for
    simulating systems in the overdamped regime where inertial effects are negligible.
    It includes thermal noise and friction to model the effect of a solvent.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    friction : float
        The friction coefficient in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    temperature : float
        The temperature of the system in Kelvin.
    friction : float
        The friction coefficient in internal time units.
    noise_amplitude : float
        The amplitude of the thermal noise.
    sqrt_one_over_masses : torch.Tensor
        The square root of the inverse of the particle masses.
    force_scale : float
        The scaling factor for forces.
    stored_tensor_for_random_numbers : torch.Tensor
        Tensor for storing random numbers for the thermal noise.
    dtype : torch.dtype
        The data type for the integrator.
        
    Raises
    ------
    NotImplementedError
        If constraints are specified, as Brownian Dynamics does not support constraints.
    """

    def __init__(self, timestep, temperature, friction, sys, dtype=None):
        """
        Initialize the BrownianDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        friction : float
            The friction coefficient in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
            
        Raises
        ------
        NotImplementedError
            If constraints are specified, as Brownian Dynamics does not support constraints.
        """
        super().__init__(timestep, sys, dtype)
        self.temperature = temperature
        self.friction = friction * constants.FS_TO_INTERNAL
        self.noise_amplitude = math.sqrt(2.0 * constants.BOLTZMANN * self.temperature * self.timestep / self.friction)
        self.sqrt_one_over_masses = torch.sqrt(1.0 / sys.masses).unsqueeze(-1).expand(-1, 3)
        self.force_scale = self.timestep / self.friction
        self.stored_tensor_for_random_numbers = torch.empty((sys.num_atoms, 3))

        if not isinstance(self.constraint_handler, PassthroughConstraintHandling):
            raise NotImplementedError("For Brownian Dynamics, constraints are not implemented.")

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            An empty list as Brownian Dynamics doesn't store persistent tensors.
        """
        return []

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Brownian dynamics integration step.
        
        This method implements the Brownian dynamics algorithm:
        1. Calculate forces and accelerations
        2. Update positions using forces and thermal noise
        3. Calculate velocities from position changes

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles (used only for output).
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator for generating thermal noise.

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

        original_pos = pos.clone()
        pos = pos + self.force_scale * self.a + self.noise_amplitude * self.sqrt_one_over_masses * \
            self.stored_tensor_for_random_numbers.normal_(generator=generator)

        vel = (pos - original_pos) / self.timestep
        return pos, vel


class LangevinDynamics(CommonIntegrator):
    """
    Langevin dynamics integrator.
    
    This class implements the Langevin dynamics algorithm, which includes
    inertial effects, thermal noise, and friction to model the effect of a solvent.
    It is suitable for simulating systems in the presence of a heat bath.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    friction : float
        The friction coefficient in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    half_timestep : float
        Half of the timestep, used in the integration algorithm.
    temperature : float
        The temperature of the system in Kelvin.
    kBT : float
        The product of Boltzmann constant and temperature.
    friction : float
        The friction coefficient in internal time units.
    vel_scale : float
        The velocity scaling factor due to friction.
    noise_amplitude : torch.Tensor
        The amplitude of the thermal noise for each particle.
    stored_tensor_for_random_numbers : torch.Tensor
        Tensor for storing random numbers for the thermal noise.
    dtype : torch.dtype
        The data type for the integrator.
        
    Raises
    ------
    NotImplementedError
        If constraints are specified, as this implementation of Langevin Dynamics 
        does not support constraints.
    """

    def __init__(self, timestep, temperature, friction, sys, dtype=None):
        """
        Initialize the LangevinDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        friction : float
            The friction coefficient in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
            
        Raises
        ------
        NotImplementedError
            If constraints are specified, as this implementation of Langevin Dynamics 
            does not support constraints.
        """
        super().__init__(timestep, sys, dtype)
        self.half_timestep = 0.5 * self.timestep
        self.temperature = temperature
        self.kBT = constants.BOLTZMANN * self.temperature
        self.friction = friction * constants.FS_TO_INTERNAL
        self.vel_scale = math.exp(-self.friction * self.timestep)
        self.noise_amplitude = torch.sqrt(self.kBT * (1 - self.vel_scale**2) / sys.masses).unsqueeze(-1).expand(-1, 3)
        self.stored_tensor_for_random_numbers = torch.empty((sys.num_atoms, 3))

        if not isinstance(self.constraint_handler, PassthroughConstraintHandling):
            raise NotImplementedError("For Langevin Dynamics, constraints are not implemented.")

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration based on forces from the system.
        
        This method calculates forces and converts them to accelerations.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the acceleration tensor.
        """
        return [self.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Langevin dynamics integration step.
        
        This method implements a simplified Langevin dynamics algorithm:
        1. Update velocities using current accelerations
        2. Update positions using half timestep
        3. Apply velocity scaling and add thermal noise
        4. Update positions for the second half timestep
        5. Update accelerations based on new positions

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator for generating thermal noise.

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        # Update 1
        vel = vel + self.timestep * self.a

        # Update 2
        pos = pos + vel * self.half_timestep
        vel = self.vel_scale * vel + self.noise_amplitude * self.stored_tensor_for_random_numbers.normal_(generator=generator)
        pos = pos + vel * self.half_timestep

        # Recalc new forces
        self.update_acceleration(pos, neighborlist, sys)
        return pos, vel


class AndersenDynamics(CommonIntegrator):
    """
    Andersen thermostat integrator.
    
    This class implements the Andersen thermostat, which maintains constant
    temperature by randomly reassigning particle velocities from a Maxwell-Boltzmann
    distribution. It simulates collisions with an implicit heat bath.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    collision_frequency : float
        The frequency of collisions with the heat bath in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    temperature : float
        The temperature of the system in Kelvin.
    base_integrator : VelocityVerlet
        The underlying velocity Verlet integrator.
    collision_frequency : float
        The frequency of collisions with the heat bath in internal time units.
    collision_probability : float
        The probability of a collision per timestep.
    stored_tensor_for_random_numbers : torch.Tensor
        Tensor for storing random numbers for collision decisions.
    dtype : torch.dtype
        The data type for the integrator.
    """

    def __init__(self, timestep, temperature, collision_frequency, sys, dtype=None):
        """
        Initialize the AndersenDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        collision_frequency : float
            The frequency of collisions with the heat bath in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """
        super().__init__(timestep, sys, dtype)
        self.base_integrator = VelocityVerlet(timestep, sys, dtype)
        self.collision_frequency = collision_frequency * constants.FS_TO_INTERNAL
        self.collision_probability = 1 - math.exp(-self.collision_frequency * self.timestep)
        self.temperature = temperature
        self.stored_tensor_for_random_numbers = torch.empty((sys.num_atoms))

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration using the base integrator.
        
        This method delegates the acceleration update to the base velocity Verlet integrator.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.base_integrator.update_acceleration(pos, neighborlist, sys)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the base integrator's acceleration tensor.
        """
        return [self.base_integrator.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Andersen dynamics integration step.
        
        This method implements the Andersen thermostat algorithm:
        1. Perform a velocity Verlet integration step
        2. Randomly reassign velocities from a Maxwell-Boltzmann distribution
           based on the collision probability

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator for collision decisions and velocity reassignment.

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        pos, vel = self.base_integrator.step(pos, vel, neighborlist, sys, generator)

        collision_random_number = self.stored_tensor_for_random_numbers.uniform_(generator=generator)

        vel = maxwell_boltzmann_distr(sys, vel, self.temperature, generator, self.collision_probability > collision_random_number)

        return pos, vel


class BerendsenDynamics(CommonIntegrator):
    """
    Berendsen thermostat integrator.
    
    This class implements the Berendsen thermostat, which maintains constant
    temperature by scaling velocities to gradually correct temperature deviations.
    Note that this thermostat does not generate the canonical ensemble.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The target temperature of the system in Kelvin.
    coupling_strength : float
        The coupling strength to the heat bath (relaxation time).
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    temperature : float
        The target temperature of the system in Kelvin.
    base_integrator : VelocityVerlet
        The underlying velocity Verlet integrator.
    coupling_strength : float
        The coupling strength to the heat bath (relaxation time).
    dtype : torch.dtype
        The data type for the integrator.
        
    Notes
    -----
    This implementation is experimental and may not match other implementations exactly.
    """

    def __init__(self, timestep, temperature, coupling_strength, sys, dtype=None):
        """
        Initialize the BerendsenDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The target temperature of the system in Kelvin.
        coupling_strength : float
            The coupling strength to the heat bath (relaxation time).
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """
        warn("Berendsen thermostat is experimental at this point of time, since there is no openMM implementation to compare to.", stacklevel=2)
        super().__init__(timestep, sys, dtype)
        self.base_integrator = VelocityVerlet(timestep, dtype)
        self.coupling_strength = coupling_strength
        self.temperature = temperature

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration using the base integrator.
        
        This method delegates the acceleration update to the base velocity Verlet integrator.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.base_integrator.update_acceleration(pos, neighborlist, sys)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the base integrator's acceleration tensor.
        """
        return [self.base_integrator.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Berendsen dynamics integration step.
        
        This method implements the Berendsen thermostat algorithm:
        1. Perform a velocity Verlet integration step
        2. Calculate the current temperature
        3. Scale velocities to gradually correct temperature deviations

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator (not used in this integrator).

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        pos, vel = self.base_integrator.step(pos, vel, neighborlist, sys, generator)
        current_temperature = sys.measure_temperature(vel)
        lambda_factor = torch.sqrt(1 + self.timestep / self.coupling_strength * (self.temperature / current_temperature - 1.0))
        vel = vel * lambda_factor

        return pos, vel


class LoweAndersenDynamics(CommonIntegrator):
    """
    Lowe-Andersen thermostat integrator.
    
    This class implements the Lowe-Andersen thermostat, which is a pairwise version
    of the Andersen thermostat. It maintains constant temperature by randomly
    reassigning relative velocities between particle pairs, preserving momentum
    conservation and hydrodynamic behavior.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    collision_frequency : float
        The frequency of collisions with the heat bath in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    temperature : float
        The temperature of the system in Kelvin.
    base_integrator : VelocityVerlet
        The underlying velocity Verlet integrator.
    collision_frequency : float
        The frequency of collisions with the heat bath in internal time units.
    collision_probability : float
        The probability of a collision per timestep.
    dtype : torch.dtype
        The data type for the integrator.
        
    Notes
    -----
    This implementation is experimental and may not match other implementations exactly.
    """

    def __init__(self, timestep, temperature, collision_frequency, sys, dtype=None):
        """
        Initialize the LoweAndersenDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        collision_frequency : float
            The frequency of collisions with the heat bath in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """

        warn("The Lowe Andersen thermostat is currently an experimental feature. While it should work mostly correct, it has not been thoroughly tested. Please be careful when using it and compare to established implementations.", stacklevel=2)
        super().__init__(timestep, sys, dtype)
        self.base_integrator = VelocityVerlet(timestep, sys, dtype)
        self.temperature = temperature
        self.timestep = timestep / constants.FS_TO_INTERNAL

        self.collision_frequency = collision_frequency * constants.FS_TO_INTERNAL
        self.collision_probability = 1 - math.exp(-self.collision_frequency * self.timestep)

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration using the base integrator.
        
        This method delegates the acceleration update to the base velocity Verlet integrator.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.base_integrator.update_acceleration(pos, neighborlist, sys)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the base integrator's acceleration tensor.
        """
        return [self.base_integrator.a]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Lowe-Andersen dynamics integration step.
        
        This method implements the Lowe-Andersen thermostat algorithm:
        1. Perform a velocity Verlet integration step
        2. Identify pairs of particles within the cutoff distance
        3. For each pair, with some probability, reassign their relative velocity
           along the line connecting them while preserving total momentum

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator for collision decisions and velocity reassignment.

        Returns
        -------
        tuple
            The updated positions and velocities.
        """
        pos, vel = self.base_integrator.step(pos, vel, neighborlist, sys, generator)

        # Extract all pairs within cutoff. One could think about re-using the distances calculated below for the next iteration of force calculation, since below the positions are not updated.
        # The thermostat is only touching the velocities. I do not see an easy way
        # to do this without producing massive spaghetti code, hence at least for
        # this general implementation I am keeping it like this.
        distances = get_distances_edge_list(pos, neighborlist, sys.periodic, sys.box)
        filter_distances = distances <= sys.cutoff
        neighborlist = neighborlist[:, filter_distances]

        collision_random_number = torch.empty(neighborlist.size(1)).uniform_(generator=generator)

        mask_for_pairs_to_update = self.collision_probability > collision_random_number
        pairs_to_update = neighborlist[:, mask_for_pairs_to_update].T

        # Precalculate as much as possible outside the look; this includes distance vectors and rescaling factors
        r_ij = pos[pairs_to_update[:, 0]] - pos[pairs_to_update[:, 1]]
        if sys.periodic:
            r_ij = periodic_correction(r_ij, sys.box)

        unit_r_ij = r_ij / torch.linalg.vector_norm(r_ij, dim=1).unsqueeze(-1)
        mu = sys.masses[pairs_to_update[:, 0]] * sys.masses[pairs_to_update[:, 1]] / \
            (sys.masses[pairs_to_update[:, 0]] + sys.masses[pairs_to_update[:, 1]])
        lambda_scaling = torch.empty(pairs_to_update.size(0)).normal_(generator=generator) * torch.sqrt(constants.BOLTZMANN * self.temperature / mu)

        # Do the actual velocity update. This has to be done sequentially, hence we cannot really use pyTorch code.
        for idx, pair in enumerate(pairs_to_update):
            i, j = pair[0], pair[1]

            velocity_difference = vel[i] - vel[j]
            factor = (lambda_scaling[idx] - torch.dot(velocity_difference, unit_r_ij[idx])) * unit_r_ij[idx]

            vel[i] = vel[i] + mu[idx] / sys.masses[i] * factor
            vel[j] = vel[j] - mu[idx] / sys.masses[j] * factor

        return pos, vel


class NoseHooverDynamics(CommonIntegrator):
    """
    Nose-Hoover thermostat integrator.
    
    This class implements the Nose-Hoover thermostat with a middle point integrator,
    which maintains constant temperature by coupling the system to a fictitious
    heat bath through an additional degree of freedom.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    collision_frequency : float
        The coupling strength to the heat bath in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
        
    Attributes
    ----------
    timestep : float
        The timestep for the integrator in internal time units.
    kBT : float
        The product of Boltzmann constant and temperature.
    dof : int
        The number of degrees of freedom in the system.
    collision_frequency : float
        The coupling strength to the heat bath in internal time units.
    vel_thermostat : torch.Tensor
        The velocity of the thermostat.
    mass_thermostat : float
        The mass of the thermostat.
    a : torch.Tensor
        The acceleration tensor.
    dtype : torch.dtype
        The data type for the integrator.
        
    References
    ----------
    Zhang+(2019), "Unified Efficient Thermostat Scheme for the Canonical Ensemble
    with Holonomic or Isokinetic Constraints via Molecular Dynamics"
    Reference code: https://github.com/Allen-Tildesley/examples/blob/master/md_nvt_lj.f90
    """

    def __init__(self, timestep, temperature, collision_frequency, sys, dtype=None):
        """
        Initialize the NoseHooverDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        collision_frequency : float
            The coupling strength to the heat bath in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        """

        # See: .venv/torchff_dev/lib/python3.10/site-packages/openmmtools/integrators.py
        super().__init__(timestep, sys, dtype)
        self.kBT = constants.BOLTZMANN * temperature
        self.dof = 3 * sys.num_atoms - self.constraint_handler.num_total_constraints
        self.collision_frequency = collision_frequency * constants.FS_TO_INTERNAL

        # self.pos_thermostat = 0.0
        self.vel_thermostat = torch.tensor(0.0)
        self.mass_thermostat = self.dof * self.kBT / self.collision_frequency**2

    def update_acceleration(self, pos, neighborlist, sys):
        """
        Update the acceleration based on forces from the system.
        
        This method calculates forces and converts them to accelerations.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        """
        self.a = sys.calc_energy(pos, neighborlist, return_forces=True)[2].to(self.dtype)

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the acceleration tensor and thermostat velocity.
        """
        return [self.a, self.vel_thermostat]

    def step(self, pos, vel, neighborlist, sys, generator=None):
        """
        Perform a single Nose-Hoover dynamics integration step.
        
        This method implements the Nose-Hoover thermostat algorithm:
        1. Propagate the thermostat and scale velocities
        2. Update velocities by half a timestep
        3. Update positions using updated velocities
        4. Apply position constraints
        5. Update accelerations based on new positions
        6. Update velocities for the second half timestep
        7. Apply velocity constraints

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the particles.
        vel : torch.Tensor
            The velocities of the particles.
        neighborlist : torch.Tensor or None
            The neighbor list for efficient force calculation.
        sys : object
            The system object containing force field information.
        generator : torch.Generator, optional
            The random number generator (not used in this integrator).

        Returns
        -------
        tuple
            The updated positions and velocities.
        """

        scale = self.propagate_thermostat(vel, sys)
        vel = scale * vel

        vel = vel + 0.5 * self.timestep * self.a
        original_pos = pos.clone()
        pos = pos + vel * self.timestep
        pos_prime = pos.clone()
        self.constraint_handler.apply_constraints(original_pos, pos_prime)

        self.update_acceleration(pos_prime, neighborlist, sys)

        pos_difference = pos_prime - pos
        if sys.periodic:
            pos_difference = periodic_correction(pos_difference, sys.box)

        vel = vel + 0.5 * self.a * self.timestep + pos_difference / self.timestep

        vel_prime = vel.clone()
        self.constraint_handler.apply_velocity_constraints(pos_prime, vel_prime)

        scale = self.propagate_thermostat(vel, sys)
        vel_prime = scale * vel_prime

        return pos_prime, vel_prime

    def propagate_thermostat(self, vel, sys):
        """
        Propagate the Nose-Hoover thermostat.
        
        This method updates the thermostat variables and calculates
        the velocity scaling factor.
        
        Parameters
        ----------
        vel : torch.Tensor
            The velocities of the particles.
        sys : object
            The system object containing information about the molecular system.
            
        Returns
        -------
        torch.Tensor
            The velocity scaling factor.
        """
        kin_energy = kinetic_energy(vel, sys)
        a_thermostat = (2.0 * kin_energy - self.dof * self.kBT) / self.mass_thermostat

        self.vel_thermostat = self.vel_thermostat + 0.25 * self.timestep * a_thermostat
        scale = torch.exp(-0.5 * self.timestep * self.vel_thermostat)
        # self.pos_thermostat = self.pos_thermostat + 0.5 * self.timestep * self.vel_thermostat

        a_thermostat = (scale * scale * 2.0 * kin_energy - self.dof * self.kBT) / self.mass_thermostat
        self.vel_thermostat = self.vel_thermostat + 0.25 * self.timestep * a_thermostat
        return scale


class NoseHooverChainDynamics(NoseHooverDynamics):
    """
    Nose-Hoover Chain thermostat integrator.
    
    This class extends the Nose-Hoover thermostat by using a chain of thermostats,
    which improves ergodicity and temperature control. It uses the Yoshida-Suzuki
    integration scheme for accurate propagation of the thermostat chain.

    Parameters
    ----------
    timestep : float
        The timestep for the integrator in femtoseconds.
    temperature : float
        The temperature of the system in Kelvin.
    collision_frequency : float
        The coupling strength to the heat bath in fs^-1.
    sys : object
        The system object containing information about the molecular system.
    dtype : torch.dtype, optional
        The data type for the integrator. If None, the default data type is used.
    chain_length : int, optional
        The number of thermostats in the chain. Default is 5.
    num_mts : int, optional
        The number of multiple time steps for thermostat integration. Default is 5.
    num_yoshidasuzuki : int, optional
        The order of the Yoshida-Suzuki integration scheme. Default is 5.
        
    Attributes
    ----------
    n_c : int
        The number of multiple time steps for thermostat integration.
    n_ys : int
        The order of the Yoshida-Suzuki integration scheme.
    chain_length : int
        The number of thermostats in the chain.
    weights : list
        The Yoshida-Suzuki integration weights.
    eta : torch.Tensor
        The positions of the thermostats.
    p_eta : torch.Tensor
        The momenta of the thermostats.
    a_thermostat : torch.Tensor
        The accelerations of the thermostats.
    mass_thermostat : torch.Tensor
        The masses of the thermostats.
    w : torch.Tensor
        The Yoshida-Suzuki weights as a tensor.
        
    References
    ----------
    Zhang+(2019), "Unified Efficient Thermostat Scheme for the Canonical Ensemble
    with Holonomic or Isokinetic Constraints via Molecular Dynamics"
    Reference code: https://github.com/Allen-Tildesley/examples/blob/master/md_nvt_lj.f90
    """

    YSWeights = {
        1: [1.0000000000000000],
        3: [0.8289815435887510, -0.6579630871775020, 0.8289815435887510],
        5: [0.2967324292201065, 0.2967324292201065, -0.1869297168804260, 0.2967324292201065, 0.2967324292201065],
        7: [0.784513610477560, 0.235573213359357, -1.17767998417887, 1.31518632068391,
            -1.17767998417887, 0.235573213359357, 0.784513610477560]
    }

    def __init__(self, timestep, temperature, collision_frequency, sys, dtype=None,
                 chain_length=5, num_mts=5, num_yoshidasuzuki=5):
        """
        Initialize the NoseHooverChainDynamics integrator.

        Parameters
        ----------
        timestep : float
            The timestep for the integrator in femtoseconds.
        temperature : float
            The temperature of the system in Kelvin.
        collision_frequency : float
            The coupling strength to the heat bath in fs^-1.
        sys : object
            The system object containing information about the molecular system.
        dtype : torch.dtype, optional
            The data type for the integrator. If None, the default data type is used.
        chain_length : int, optional
            The number of thermostats in the chain. Default is 5.
        num_mts : int, optional
            The number of multiple time steps for thermostat integration. Default is 5.
        num_yoshidasuzuki : int, optional
            The order of the Yoshida-Suzuki integration scheme. Default is 5.
            
        Raises
        ------
        AssertionError
            If an invalid Yoshida-Suzuki value is provided or if chain_length is not a positive integer.
        """
        super().__init__(timestep, temperature, collision_frequency, sys, dtype)
        assert num_yoshidasuzuki in self.YSWeights.keys(), f"Invalid Yoshida-Suzuki value. Allowed: {list(self.YSWeights.keys())}"
        assert ((chain_length > 0) & (int(chain_length) == chain_length)
                ), "Chain length must be ≥1 and an integer. Use NoseHooverDynamics for single thermostat."

        self.n_c = num_mts
        self.n_ys = num_yoshidasuzuki
        self.chain_length = chain_length
        self.weights = self.YSWeights[self.n_ys]

        self.kBT = constants.BOLTZMANN * temperature
        self.dof = 3 * sys.num_atoms - self.constraint_handler.num_total_constraints
        self.collision_frequency = collision_frequency * constants.FS_TO_INTERNAL

        initial_mass_thermostat = self.kBT / self.collision_frequency**2

        # Thermostat parameters
        self.eta = torch.zeros(self.chain_length)  # Thermostat positions
        self.p_eta = torch.zeros(self.chain_length)
        self.a_thermostat = torch.ones(self.chain_length) * (-self.collision_frequency**2)
        self.mass_thermostat = torch.ones(self.chain_length) * initial_mass_thermostat
        self.w = torch.tensor(self.weights, dtype=self.dtype)
        self.mass_thermostat[0] = self.dof * initial_mass_thermostat  # Set mass for first thermostat particle

    def get_variables_to_detach(self):
        """
        Get the variables that should be detached from the computation graph.
        
        Returns
        -------
        list
            A list containing the acceleration tensor and thermostat variables.
        """
        return [self.a, self.p_eta, self.eta, self.a_thermostat, self.mass_thermostat]

    @torch.compiler.disable(recursive=True)
    def propagate_thermostat(self, vel, sys):
        """ 
        Propagate the Nosé-Hoover chain.
        
        This method implements the Yoshida-Suzuki integration scheme for
        the Nosé-Hoover chain, as described in Eq. (35) in Martyna+(1996).
        
        Parameters
        ----------
        vel : torch.Tensor
            The velocities of the particles.
        sys : object
            The system object containing information about the molecular system.
            
        Returns
        -------
        float
            The velocity scaling factor.
            
        References
        ----------
        Martyna, G. J., Tuckerman, M. E., Tobias, D. J., & Klein, M. L. (1996).
        Explicit reversible integrators for extended systems dynamics.
        Molecular Physics, 87(5), 1117-1157.
        """
        scale = 1.0
        kin_energy = kinetic_energy(vel, sys)
        self.a_thermostat[0] = (2.0 * kin_energy - self.dof * self.kBT) / self.mass_thermostat[0]
        M = self.chain_length
        for ncval in range(self.n_c):
            for nysval in range(self.n_ys):
                wdt = self.w[nysval] * self.timestep / self.n_c
                # Update last thermostat momentum
                self.p_eta[-1] = self.p_eta[-1] + 0.25 * wdt * self.a_thermostat[-1]
                # Reverse update for chain elements
                for j in reversed(range(M - 1)):
                    aa = torch.exp(-0.125 * wdt * self.p_eta[j + 1])
                    self.p_eta[j] = aa * (aa * self.p_eta[j] + 0.25 * wdt * self.a_thermostat[j])
                # Scale velocities and update positions
                aa = torch.exp(-0.5 * wdt * self.p_eta[0])
                scale = scale * aa
                self.eta = self.eta + 0.5 * wdt * self.p_eta
                # Recalculate forces
                self.a_thermostat[0] = (scale**2 * 2.0 * kin_energy - self.dof * self.kBT) / self.mass_thermostat[0]
                # Forward update for chain elements
                if M > 1:
                    aa = torch.exp(-0.125 * wdt * self.p_eta[1:])
                    self.p_eta[:-1] = aa * (aa * self.p_eta[:-1] + 0.25 * wdt * self.a_thermostat[:-1])
                    self.a_thermostat[1:] = (self.mass_thermostat[:-1] * self.p_eta[:-1]**2 - self.kBT) / self.mass_thermostat[1:]
                self.p_eta[-1] = self.p_eta[-1] + 0.25 * wdt * self.a_thermostat[-1]
        return scale
