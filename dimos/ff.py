# NEC Software Library Academic Use Licence Terms (the 'Terms')

# THESE TERMS APPLY TO THE LICENSEE'S USE OF THE "SOFTWARE" AS IDENTIFIED BELOW 
# (INCLUDING ANY PORTION OR ELEMENT OF THE SOFTWARE), INCLUDING ANY UPDATES TO 
# THE SOFTWARE RECEIVED FROM NEC, AND BY DOWNLOADING OR USING THE SOFTWARE (OR 
# RECEIVING ANY UPDATES TO THE SOFTWARE) THE LICENSEE AGREES TO BE BOUND BY THESE 
# TERMS. 

# THESE TERMS ARE A CONTRACTUAL AGREEMENT BETWEEN THE LICENSEE AND NEC. IF THE 
# LICENSEE DOES NOT AGREE TO THESE TERMS, IT CANNOT DOWNLOAD THE SOFTWARE OR USE 
# THE SOFTWARE FOR ANY PURPOSE.


# 1.	Software licence rights for Academic Use

# 1.1	The Licensee is granted a personal, non-exclusive, worldwide, 
# non-transferrable, non-sublicensable, royalty-free and limited licence to use, 
# reproduce, copy, create derivate works of and/or make modifications to the 
# Software solely for Academic Use; and to use and copy the Documentation solely 
# in connection with the rights granted in the foregoing.

# 1.2	The Licensee acknowledges that, unless otherwise expressly agreed in 
# writing by NEC, the licence granted under clause 1.1 does not permit the 
# commercial use of the Software for any purpose, including any distribution or 
# resale of the Software (either directly, or indirectly as part of any package 
# or bundle of software, cloud software or software as a service product), any 
# use in collaborations between academic and commercial entities (including any 
# funding of PhD activities by commercial entities), or any non-commercial use of 
# the Software by a commercial entity.

# 1.3	For the avoidance of doubt, the Licensee is not permitted to use the 
# Software and/or the Documentation under these Terms for any commercial purposes 
# whilst representing that such use is a form of Academic Use. If NEC has the 
# reasonable belief that the Licensee is using the Software and/or the 
# Documentation for any commercial purposes then such use will be deemed a breach 
# of these Terms and NEC may terminate the licence granted under these Terms with 
# immediate effect in accordance with clause 7.2(a).

# 1.4	The Licensee must use the Software and/or the Documentation in 
# accordance with any applicable laws and regulations, including any applicable 
# import and export control laws, associated embargo and sanction rules and 
# regulations relating to the export of software, or materials or products in 
# connection with the export of software. For clarity, the parties acknowledge 
# that the export control laws of United States and the export/import control 
# laws of other countries may govern the use of the Software and/or the 
# Documentation. The Licensee therefore agrees to comply fully with all relevant 
# export laws and regulations, including those of Japan, European Union (and 
# European Union member states), United Kingdom, and the United States, to ensure 
# that the Software and/or the Documentation or any portion thereof is exported, 
# directly or indirectly, in violation of export laws and regulations. This 
# clause will survive the termination or expiration of these Terms.

# 1.5	The Licensee shall ensure that only its Representatives use the 
# Software and that such use is at all times in accordance with these Terms. The 
# Licensee shall procure that each Representative is aware of, and complies with, 
# the obligations and restrictions imposed on the Licensee under these Terms. 

# 1.6	The Licensee shall be liable for the acts and omissions of its 
# Representatives as if they were its own, and shall not provide access to the 
# Software (or permit access by) anyone other than a Representative.

# 1.7	If the Licensee wishes to use the Software, the Documentation and/or 
# any Derivative Works for commercial purposes then it must enter into a separate 
# commercial licence agreement with NEC, on such terms as NEC acting in its sole 
# discretion requires from time to time. For the avoidance of doubt, NEC reserves 
# the right to not enter into any such commercial licence agreement or other 
# arrangements with the Licensee or any third party.


# 2.	Licence rights regarding Derivative Works

# 2.1	If the Licensee develops any derivate works of the Software, any part 
# of the Software and/or any modifications to the Software, either as the result 
# of a pull request received by NEC from the Licensee or a Representative or 
# otherwise (each a 'Derivative Work') or any product or service that uses or 
# incorporates any Derivative Works then:
# (a)	subject to clause 5.1, as between the Licensee and NEC, all 
# Intellectual Property Rights in the Derivative Works belong to and shall remain 
# vested in the Licensee;
# (b)	the Licensee hereby grants to NEC a perpetual, fully paid-up, 
# non-exclusive, royalty-free, transferrable, sublicensable, irrevocable licence 
# to use, copy, modify, reproduce and/or create derivate works of the Derivative 
# Works for any purpose; 
# (c)	the Licensee must provide NEC a copy of the source code of any 
# Derivative Works via its code repository located at https://github.com/nec-research/DIMOS;
# (d)	the Licensee must provide a copy of these Terms with the Derivative 
# Work(s);
# (e)	the Licensee must prominently display "Built using NEC technology" on 
# any related software description, website, user interface, about page, software 
# specification or other technical documentation; and
# (f)	the Licensee must include in any notice text file distributed as part 
# of any Derivate Work: "[Derivate Work] is licensed under the NEC Software 
# Library Academic License. Copyright Â© 2025 NEC Laboratories Europe GmbH. All 
# Rights Reserved. 

# 2.2	The Licensee is only permitted to use any Derivative Works for Academic 
# Use. The Licensee is not permitted to use any Derivative Works for commercial 
# use, or to permit or otherwise enable any third party to use any Derivative 
# Works for commercial use. Section 1 of the Terms do accordingly apply. 


# 3.	Acceptable use policy

# 3.1	As a condition of use, the Licensee agrees not to use the Software, nor 
# permit it to be used by any Representative or otherwise: 
# (a)	for any purpose that is unlawful under any applicable law or prohibited 
# by these Terms; 
# (b)	to commit any act of fraud or money laundering or otherwise be used in 
# any activities that are deceptive or harmful to others; 
# (c)	to create, store, access, transfer to any third party or otherwise 
# distribute any code or device intended to interfere with, or having the effect 
# of interfering adversely with, the operation of any hardware or software, 
# including any virus, disabling code (including code intended to limit or 
# prevent any use any software or system) or other malicious software (including 
# bugs, worms, logic bombs, malware, trojan horses, ransomware and spyware), or 
# any other material which is unlawful;
# (d)	for the purposes of promoting unsolicited advertising or sending spam, 
# or for the creation or promotion of disinformation;
# (e)	for the purposes of creating, promoting or furthering any defamatory 
# content, including any defamatory statements, images or other media;
# (f)	to simulate communications from any third party service or entity (i.e. 
# phishing communications) in order to collect identity information, 
# authentication credentials, or other information; 
# (g)	in any manner that disrupts the operations, business, equipment, 
# websites or systems of any person or entity (including any denial of service 
# and similar attacks);
# (h)	in any manner that harms or may endanger minors or any other person, or 
# may cause damage or loss to any tangible property or the environment;
# (i)	to gain unauthorised access to or use of any computers, data, systems, 
# accounts or networks of any person;
# (j)	to attempt to circumvent any security controls or mechanisms; 
# (k)	in any manner that engages in or promotes the harassment, abuse, 
# bullying or discrimination of any individuals or groups of individuals; 
# (l)	in any manner that violates, infringes upon, or misappropriates the 
# Intellectual Property Rights or proprietary rights of NEC or any third party; 
# (m)	to sell, publish, rent, lease or otherwise commercialise the Software 
# or any Derivative Work, or assist any third party in relation to the same; or
# (n)	to reverse engineer, decompile or disassemble the Software except and 
# solely to the extent permitted under these Terms.


# 4.	No warranty

# 4.1	The Software and Documentation (including any part thereof and/or any 
# updates provided under these Terms) (together the 'NEC Materials') are provided 
# "as is" and without warranty to the maximum extent permitted by law. To the 
# extent permitted by law, NEC gives no express or implied warranties, 
# guarantees, conditions or obligations under these Terms, including any express 
# or implied terms relating to quality, fitness for any particular purpose, 
# title, non-infringement, or ability to achieve a particular result. 

# 4.2	The Licensee acknowledges that it is solely responsible for determining 
# the appropriateness of using the NEC Materials and assumes any and all risks 
# associated with its use of the NEC Materials, any Derivative Works and/or any 
# other outputs or results relating to any of the foregoing.


# 5.	Intellectual property rights

# 5.1	As between the Licensee and NEC, all rights, including all Intellectual 
# Property Rights, in the NEC Materials belong to and shall remain vested in NEC. 
# Except for the rights expressly granted in these Terms, the Licensee and/or any 
# Representative shall not acquire in any way any title, rights of ownership, or 
# any other Intellectual Property Rights or other rights of any nature in the NEC 
# Materials and no Intellectual Property Rights or other rights are transferred 
# or licensed as a result of these Terms.

# 5.2	The Licensee acknowledges and agrees that certain aspects of the 
# Software provided under these Terms are based on or powered by Open Source 
# Software, either developed by NEC (and which is not based on or derived from 
# Open Source Software licensed to NEC) or derived from, or incorporated into 
# and/or distributed with other Open Source Software licensed to NEC.

# 5.3	NEC may use any feedback and suggestions for improvement relating to 
# the NEC Materials provided by the Licensee or any Representative without charge 
# or limitation ('Feedback'). The Licensee hereby assigns (or shall procure the 
# assignment of) all Intellectual Property Rights in the Feedback with full title 
# guarantee (including by way of present assignment of future Intellectual 
# Property Rights) to NEC at the time such Feedback is first provided to NEC.

# 5.4	The Licensee acknowledges that the Software may collect information 
# about its use of the NEC Materials under these Terms. NEC may use this 
# information to provide and/or improve its services and products. 

# 5.5	If the Licensee (including any Representatives) institutes any claim or 
# other proceedings against NEC or any other entity alleging that any NEC 
# Materials (including any outputs or results), or any part thereof, constitute 
# an infringement of any third party rights, including any Intellectual Property 
# Rights, then any rights granted to the Licensee under these Terms shall 
# immediately terminate.  

# 5.6	The Licensee shall indemnify NEC from and against any losses, claims, 
# damages, liability, costs (including legal and other professional fees) and 
# expenses incurred by NEC as a result of or in connection with any third party 
# action, demand or claim relating to use of the Software and the Documentation 
# if such use is against these Terms or to any transmission, receipt, copying, 
# installation, use, possession or other utilisation of any Derivative Work.


# 6.	Limitation of liability
# 6.1	To the extent permitted by law, NEC shall not be liable to the Licensee 
# (and/or its Representatives) under these Terms for any consequential, indirect 
# or special losses, any loss of profit or revenue; destruction, loss of use or 
# corruption of data; loss or corruption of software or systems; loss or damage 
# to equipment; loss of opportunity; and/or harm to reputation or loss of 
# goodwill.

# 6.2	Subject to clause 6.1 and to the extent permitted by law, NEC's 
# aggregate liability to the Licensee (and/or its Representatives) under these 
# Terms shall not exceed â¬500.

# 6.3	The rights and remedies provided under these Terms are in addition to, 
# and not exclusive of, any rights or remedies provided by law.


# 7.	Term and termination

# 7.1	These Terms shall commence upon the sooner of the Licensee's: (i) 
# acceptance of these Terms; or (ii) access to or download of any of the NEC 
# Materials, and will continue in full force and effect until terminated in 
# accordance with the provisions of these Terms.

# 7.2	NEC may terminate these Terms with immediate effect without notice if: 
# (a)	the Licensee (including any Representatives) is in breach of any 
# provision of these Terms; 
# (b)	the Licensee takes or has taken against it (other than in relation to a 
# solvent restructuring) any step or action towards its entering bankruptcy, 
# administration, provisional liquidation or any composition or arrangement with 
# its creditors, or it entering into a procedure in any jurisdiction with a 
# similar effect to a procedure listed above; or 
# (c)	the Licensee undergoes a change in beneficial ownership of more than 
# 50% of the issued share capital of the company or a change in the legal power 
# to direct or cause the direction of the general management of the company. 

# 7.3	Upon termination of these Terms for any reason:
# (a)	all rights granted by NEC under these Terms shall immediately cease; 
# (b)	the Licensee shall (and shall ensure that its Representatives shall) 
# cease all use of the NEC Materials;
# (c)	the Licensee shall (and shall procure that each Representatives shall) 
# destroy and delete or, if requested by NEC, return any copies of the Software 
# and/or the Documentation in its possession or control (or in the possession or 
# control of any Representative); and
# (d)	any provision of these Terms that expressly or by implication is 
# intended to continue in force on or after termination or expiry of these Terms 
# shall remain in full force and effect.


# 8.	General

# 8.1	Assignment. The Licensee shall not assign, transfer, mortgage, charge, 
# subcontract, delegate, declare a trust over or deal in any other manner with 
# any of its rights and obligations under these Terms without the prior written 
# consent of NEC. NEC may at any time assign, mortgage, charge, delegate, declare 
# a trust over or deal in any other manner with any or all of its rights under 
# these Terms.

# 8.2	Variation. No variation of these Terms shall be effective unless it is 
# in writing and signed by the parties (or their authorised representatives).

# 8.3	Entire agreement. These Terms constitute the entire agreement between 
# NEC and the Licensee and supersedes and extinguishes all previous agreements 
# and understandings between them, whether written or oral, relating to its 
# subject matter.

# 8.4	No partnership or agency. NEC and the Licensee are independent and are 
# not partners or principal and agent and these Terms does not establish any 
# joint venture, trust, fiduciary or other relationship between them, other than 
# the contractual relationship expressly provided for in it. Neither NEC or the 
# Licensee shall have, nor shall represent that it has, any authority to make any 
# commitments on the other's behalf.

# 8.5	Severance. If any provision of these Terms (or part of any provision) 
# is or becomes illegal, invalid or unenforceable, the legality, validity and 
# enforceability of any other provision of these Terms shall not be affected.

# 8.6	Waiver. A waiver of any right or remedy under these Terms or by any 
# applicable law is only effective if given in writing and shall not be deemed a 
# waiver of any subsequent right or remedy. A failure or delay to exercise any 
# right or remedy provided under these Terms or by law shall not constitute a 
# waiver of that or any other right or remedy, nor shall it prevent or restrict 
# any further exercise of that or any other right or remedy. No single or partial 
# exercise of any right or remedy provided under these Terms or by any applicable 
# law shall prevent or restrict the further exercise of that or any other right 
# or remedy.

# 8.7	Third party rights. Nothing in these Terms confers or purports to 
# confer on any third party any right to enforce any provision of these Terms.

# 8.8	Further assurance. The Licensee (at its own cost) shall, and shall use 
# all reasonable endeavours to procure that any necessary third party shall, 
# promptly execute and deliver such documents and perform such acts as may 
# reasonably be required for the purpose of giving full effect to these Terms.

# 8.9	Governing law and jurisdiction. These Terms and any dispute or claim 
# (including non-contractual disputes or claims) arising out of or in connection 
# with it or its subject matter or formation shall be governed by and construed 
# in accordance with the law of England and Wales. Any dispute or claim arising 
# out of, or in connection with these Terms or its subject matter or formation 
# (including non-contractual disputes or claims) shall be subject to the 
# exclusive jurisdiction of the courts of England and Wales. 


# 9.	Definitions and interpretation
# In these Terms the following words and expressions shall have the following 
# meanings:

# 9.1	"Academic Use" means the use by accredited educational or research 
# institutions for non-commercial purposes, including academic research and/or 
# teaching. 

# 9.2	"Documentation" means description and specification of the Software, or 
# the relevant instructions as to how to use the Software, or other technical 
# manuals or documentation for the Software as made available by NEC from time to 
# time.

# 9.3	"Intellectual Property Rights" means any and all copyright, rights in 
# inventions, patents, know-how, trade secrets, trade marks and trade names, 
# service marks, design rights, rights in get-up, database rights and rights in 
# data, semiconductor chip topography rights, utility models, domain names and 
# all similar rights and, in each case: (a) whether registered or not; (b) 
# including any applications to protect or register such rights; (c) including 
# all renewals and extensions of such rights or applications; (d) whether vested, 
# contingent or future; and (e) wherever existing.

# 9.4	"Licensee" means the legal entity accessing or downloading the Software 
# under these Terms.

# 9.5	"NEC" means NEC Laboratories Europe GmbH, a company incorporated under 
# the laws of Germany with registration number HRB 728558 (VAT No.: DE313703076), 
# being established at Kurfuersten-Anlage 36, 69115 Heidelberg, Germany.

# 9.6	"NEC Software Library" means the software library as available at 
# https://github.com/nec-research/DIMOS.

# 9.7	"Open Source Software" means software which is included or combined 
# with the Software and which is provided to NEC under terms and conditions other 
# than those set out under these Terms, including any âopen sourceâ software 
# falling within the Open Source Definition issued by the Open Source Initiative 
# (www.opensource.org/docs/osd) and/or any âfree softwareâ as defined by the Free 
# Software Foundation (www.gnu.org/philosophy/free-sw.html).

# 9.8	"Representatives" means, as applicable, the employees, contractors, 
# officers, directors, agents, students of the Licensee and/or any other 
# representatives acting on the Licensee's behalf.

# 9.9	"Software" means the applicable software accessed or downloaded from 
# the NEC Software Library.

# 9.10	Clause and paragraph headings shall not affect the interpretation of 
# these Terms.

# 9.11	A reference to legislation or a legislative provision is a reference to 
# it as amended, extended or re-enacted from time to time, and shall include all 
# subordinate legislation made from time to time under that legislation.

# 9.12	The provisions in these Terms shall apply to the exclusion of any other 
# terms that the Licensee seeks to impose or incorporate, or which are implied by 
# law, trade custom, practice or course of dealing.

# 9.13	Any words following the terms including, include, in particular, for 
# example or any similar expression shall be interpreted as illustrative and 
# shall not limit the sense of the words preceding those terms.

# 9.14	These Terms are drafted in the English language. Any notice or other 
# communication given under or in connection with these Terms shall be in 
# English. All other documents provided under or in connection with these Terms 
# shall be in English, or accompanied by a certified English translation. The 
# English language version of these Terms and any notice, communication or other 
# document relating to these Terms shall prevail over any translation and any 
# version in any other language.



"""
Classical force field module.

This module provides classes for handling different types of force fields, including
classical force fields from Amber and Gromacs. It implements force field parameter
reading, energy calculations, and system setup.

The module contains the following main classes:
- MinimalSystem: Base class providing minimal force field functionality
- ClassicalParmedForceField: Class for handling classical force fields using ParmEd
- AmberForceField: Class specifically for Amber force fields
- GromacsForceField: Class specifically for Gromacs force fields
"""

import torch
import parmed
import math
from warnings import warn

from dimos.energy import NonbondedInteractionsEwald, NonbondedInteractionsCutoff, NonbondedInteractionsNoCutoff, HarmonicBond, HarmonicAngle, Torsion, CHARMMTorsion, DispersionCorrection, CmapCorrection
from dimos.constraints import ConstraintsHandling, PassthroughConstraintHandling
from dimos.utils import measure_temperature, periodic_correction
from dimos import constants

# Nonbonded-types: Cutoff, NoCutoff, Ewald, PME

class MinimalSystem():
    """
    Base class providing minimal force field functionality.

    This class implements basic force field operations like energy calculations
    and boundary condition handling. It serves as a foundation for more specific
    force field implementations.

    Parameters
    ----------
    unit_system : str, optional
        The unit system to use ("amber" by default)
    create_graph : bool, optional
        Whether to create computation graphs for autograd (False by default)
    dtype : torch.dtype, optional
        Data type for torch tensors (default is torch.get_default_dtype())

    Attributes
    ----------
    dtype : torch.dtype
        Data type for torch tensors
    all_exclusions : torch.Tensor
        Tensor containing all exclusions
    unit_system : str
        The unit system being used
    cv_force : None
        Placeholder for collective variable force
    constraint_handler : PassthroughConstraintHandling
        Handler for constraints
    nonbonded_force_components : list
        List of nonbonded force components
    bonded_force_components : list
        List of bonded force components
    create_graph : bool
        Whether to create computation graphs
    """

    def __init__(self, unit_system="amber", create_graph=False, dtype=None):
        if dtype is None:
            dtype = torch.get_default_dtype()
        self.dtype = dtype

        self.all_exclusions = torch.tensor([])
        constants.init_constants_in_unit_system(unit_system)
        self.unit_system = unit_system

        self.cv_force = None
        self.constraint_handler = PassthroughConstraintHandling()

        self.nonbonded_force_components = []
        self.bonded_force_components = []
        self.create_graph = create_graph

    def apply_boundary_conditions(self, pos: torch.Tensor) -> torch.Tensor:
        """
        Apply periodic boundary conditions to the positions.

        Parameters
        ----------
        pos : torch.Tensor
            positions of the atoms.

        Returns
        -------
        torch.Tensor
            positions after applying boundary conditions.
        """
        return pos - torch.floor(pos / self.box) * self.box
    
    def update_box(self, box):
        """
        Update the simulation box dimensions.

        Updates the box dimensions for the system and all force components.

        Parameters
        ----------
        box : torch.Tensor
            The new box dimensions
        """
        self.box = box
        for nonbonded in self.nonbonded_force_components:
            nonbonded.update_box(box)
        for bonded in self.bonded_force_components:
            bonded.update_box(box)

    def calc_energy(self, pos: torch.Tensor, neighborlist, return_forces: bool = False, print_energies=False):
        """
        Calculate the energy of the system.

        Parameters
        ----------
        pos : torch.Tensor
            The positions of the atoms.
        neighborlist : object
            The neighbor list.
        return_forces : bool, optional
            Whether to return forces (default is False).
        print_energies : bool, optional
            Whether to print individual energy components (default is False).

        Returns
        -------
        energy : torch.Tensor
            The total energy of the system.
        forces : torch.Tensor, optional
            The forces on the atoms (if return_forces is True).
        acceleration : torch.Tensor, optional
            The acceleration of the atoms (if return_forces is True).
        """
        pos = pos.to(self.dtype)

        energy = 0.0
        for force in self.bonded_force_components:
            energy_component = force.calc_energy(pos)
            if print_energies:
                print(force, energy_component.item())
            energy = energy + energy_component

        for force in self.nonbonded_force_components:
            if self.use_neighborlist:
                energy_component = force.calc_energy(pos, neighborlist)
                if print_energies:
                    print(force, energy_component.item())
                energy = energy + energy_component
            else:
                energy_component = force.calc_energy(pos, None)
                if print_energies:
                    print(force, energy_component.item())
                energy = energy + energy_component
        if self.cv_force is not None:
            energy_component = self.cv_force.calc_energy(pos)
            if print_energies:
                print(self.cv_force, energy_component.item())
            energy = energy + energy_component

        if not return_forces:
            return energy

        if self.create_graph:
            forces = -torch.autograd.grad(
                energy.sum(), pos, retain_graph=True, create_graph=True
            )[0]
        else:
            forces = -torch.autograd.grad(
                energy.sum(), pos, retain_graph=False, create_graph=False
            )[0]   

        acceleration = forces / self.masses.unsqueeze(-1)
        return energy, forces, acceleration

    def measure_temperature(self, vel):
        """
        Measure the temperature of the system.

        Parameters
        ----------
        vel : torch.Tensor
            Velocities of the particles

        Returns
        -------
        float
            The temperature of the system
        """
        if self.constraint_handler is not None:
            return measure_temperature(vel, self, self.constraint_handler.num_total_constraints)
        else:
            return measure_temperature(vel, self, 0)


class ClassicalParmedForceField(MinimalSystem):
    """
    A class to represent a classical force field using ParmEd.

    This class provides functionality for reading and handling classical force fields
    using ParmEd, supporting both Amber and Gromacs force field formats.

    Parameters
    ----------
    parameter_file : str
        Path to the parameter file
    xyz_file : str, optional
        Path to the xyz coordinate file
    cutoff : float, optional
        Cutoff distance for nonbonded interactions (default is 9)
    switch_distance : float, optional
        Switching distance for nonbonded interactions (default is 7.5)
    excluded_bonded_atoms : list, optional
        List of atoms to exclude from bonded interactions
    dispersion_correction : bool, optional
        Whether to apply dispersion corrections (default is False)
    nonbonded_type : str, optional
        Type of nonbonded interactions ("Cutoff" by default)
    unit_system : str, optional
        Unit system to use ("amber" by default)
    constraint_option : str, optional
        Option for handling constraints
    periodic : bool, optional
        Whether to use periodic boundary conditions
    create_graph : bool, optional
        Whether to create computation graphs (False by default)
    dtype : torch.dtype, optional
        Data type for torch tensors

    Attributes
    ----------
    parameter_set_parmed : parmed.Structure
        ParmEd structure containing force field parameters
    num_atoms : int
        Number of atoms in the system
    excluded_bonded_atoms : list
        List of excluded bonded atoms
    cutoff : float
        Cutoff distance
    switch_distance : float
        Switching distance
    pdb_writer : parmed.formats.pdb.PDBFile
        PDB file writer
    pdb_counter : int
        Counter for PDB files
    cv_force : None
        Placeholder for collective variable force
    """

    def __init__(
            self,
            parameter_file,
            xyz_file=None,
            cutoff: float = 9,
            switch_distance: float = 7.5,
            excluded_bonded_atoms=None,
            dispersion_correction=False,
            nonbonded_type: str = "Cutoff",
            unit_system="amber",
            constraint_option=None,
            periodic=None,
            create_graph=False,
            dtype=None):
        """
        Initialize the ClassicalParmedForceField class.

        Parameters
        ----------
        cutoff : float, optional
            Cutoff distance for nonbonded interactions (default is 9).
        switch_distance : float, optional
            Switching distance for nonbonded interactions (default is 7.5).
        nonbonded_type : str, optional
            Type of nonbonded interactions (default is "Cutoff").
        unit_system : str, optional
            Unit system to use (default is "amber").
        """
        if dtype is None:
            dtype = torch.get_default_dtype()

        super().__init__(unit_system, create_graph, dtype)

        parameter_set_parmed = parmed.load_file(parameter_file, xyz=xyz_file)
        self.parameter_set_parmed = parameter_set_parmed

        self.num_atoms = len(parameter_set_parmed.atoms)

        self.excluded_bonded_atoms = excluded_bonded_atoms

        self.cutoff = cutoff
        self.switch_distance = switch_distance

        self.pdb_writer = parmed.formats.pdb.PDBFile("")
        self.pdb_counter = 0

        self.cv_force = None

        self.set_box(parameter_set_parmed, periodic, nonbonded_type)

        # Add bonded energy contributions
        bond_parameters, bond_list, self.bond_exclusions = self.get_bond_parameters(parameter_set_parmed)
        if bond_list.size(0) > 0:
            self.bonded_force_components.append(HarmonicBond(bond_list, bond_parameters, self.periodic, self.box))

        urey_bradley_parameters, urey_bradley_list, urey_bradley_exclusions = self.get_urey_bradley(parameter_set_parmed)
        if urey_bradley_list.size(0) > 0:
            self.bonded_force_components.append(HarmonicBond(urey_bradley_list, urey_bradley_parameters, self.periodic, self.box))

        angle_list, angle_parameters, angle_exclusions = self.get_angle_parameters(parameter_set_parmed)

        if angle_list.size(0) > 0:
            self.bonded_force_components.append(HarmonicAngle(angle_list, angle_parameters, self.periodic, self.box))

        dihedral_list, dihedrals_parameters, self.dihedral_exclusions, improper_list, impropers_parameters, CHARMM = self.get_dihedral_parameters(
            parameter_set_parmed)
        if dihedral_list.size(0) > 0:
            self.bonded_force_components.append(Torsion(dihedral_list, dihedrals_parameters, self.periodic, self.box))
        if improper_list.size(0) > 0:
            if CHARMM:
                self.bonded_force_components.append(CHARMMTorsion(improper_list, impropers_parameters, self.periodic, self.box))
            else:
                self.bonded_force_components.append(Torsion(improper_list, impropers_parameters, self.periodic, self.box))

        cmap_contribution = self.get_cmap_parameters(parameter_set_parmed)
        for force in cmap_contribution:
            self.bonded_force_components.append(force)

        # Gather all exclusions together, since they are needed for the nonbonded interactions

        self.all_exclusions = torch.cat((self.bond_exclusions, angle_exclusions, self.dihedral_exclusions), dim=-1)

        # Add nonbonded energy contributions
        self.sigmas, self.epsilons, self.charges, self.masses = self.get_nonbonded_parameters(parameter_set_parmed)

        self.scee, self.scnb = self.check_generic_adjusts(dihedrals_parameters)

        if len(parameter_set_parmed.adjusts) > 0:
            sigmas_adjust, epsilons_adjust, adjust_list = self.check_explicit_adjusts(parameter_set_parmed)
            original_epsilons = torch.sqrt(self.epsilons[adjust_list[0]]*self.epsilons[adjust_list[1]])
            factors_epsilon = original_epsilons/epsilons_adjust
            original_sigmas = (0.5 * (self.sigmas[adjust_list[0]] + self.sigmas[adjust_list[1]]))**6
            factors_sigma = original_sigmas/sigmas_adjust
            self.explicit_adjusts = True

            if torch.isclose(factors_sigma, torch.tensor(1.0)).all() and torch.isclose(factors_epsilon, factors_epsilon[0]).all():
                warn("Explicit adjusts defined, but unnecessary. Setting simple factor instead!")
                sigmas_adjust = torch.tensor([])
                epsilons_adjust = torch.tensor([])
                adjust_list = torch.tensor([])
                self.explicit_adjusts = False
                self.scnb = factors_epsilon[0]
        else:
            sigmas_adjust = torch.tensor([])
            epsilons_adjust = torch.tensor([])
            adjust_list = torch.tensor([])
            self.explicit_adjusts = False

        match nonbonded_type:
            case "Cutoff" | "RFA":
                self.use_neighborlist = True
                solvent_dielectric = 78.5
                self.nonbonded_force_components.append(
                    NonbondedInteractionsCutoff(
                        self.sigmas,
                        self.epsilons,
                        sigmas_adjust,
                        epsilons_adjust,
                        adjust_list,
                        self.charges,
                        self.cutoff,
                        self.switch_distance,
                        solvent_dielectric,
                        self.scnb,
                        self.scee,
                        self.dihedral_exclusions,
                        self.periodic,
                        self.box))
            case "NoCutoff":
                self.use_neighborlist = False
                self.nonbonded_force_components.append(
                    NonbondedInteractionsNoCutoff(
                        self.sigmas,
                        self.epsilons,
                        sigmas_adjust,
                        epsilons_adjust,
                        adjust_list,
                        self.charges,
                        self.scnb,
                        self.scee,
                        self.dihedral_exclusions,
                        self.all_exclusions,
                        self.periodic,
                        self.box))
            case "Ewald" | "PME":
                self.use_neighborlist = True
                tolerance = 5e-4
                self.nonbonded_force_components.append(
                    NonbondedInteractionsEwald(
                        self.sigmas,
                        self.epsilons,
                        sigmas_adjust,
                        epsilons_adjust,
                        adjust_list,
                        self.charges,
                        self.cutoff,
                        self.switch_distance,
                        tolerance,
                        self.scnb,
                        self.scee,
                        self.all_exclusions,
                        self.dihedral_exclusions,
                        self.periodic,
                        self.box,
                        method=nonbonded_type))
            case None:
                self.use_neighborlist = True
            case _:
                raise Exception("Nonbonded method must be Cutoff, NoCutoff, Ewald, or PME.")

        if dispersion_correction:
            self.bonded_force_components.append(DispersionCorrection(self.sigmas, self.epsilons, self.cutoff, self.switch_distance, self.box))

        # Set up constraints in the system

        if not constraint_option == "" and constraint_option is not None:
            self.constraint_atoms, self.constraint_equilibrium = self.extract_constraints(constraint_option, parameter_set_parmed)

            self.constraint_handler = ConstraintsHandling(
                self.constraint_atoms,
                self.constraint_equilibrium,
                self.masses,
                self.num_atoms,
                angle_list,
                angle_parameters,
                tolerance=0.002,
                periodic=self.periodic,
                box=self.box)

        # Set some parameters in case a barostat is used
        self.extract_num_molecules_for_barostat(parameter_set_parmed)

    def set_box(self, parameter_set_parmed, periodic, nonbonded_type):
        """
        Set the simulation box parameters.

        Parameters
        ----------
        parameter_set_parmed : parmed.Structure
            ParmEd structure containing force field parameters
        periodic : bool
            Whether to use periodic boundary conditions
        nonbonded_type : str
            Type of nonbonded interactions
        """
        if parameter_set_parmed.box is None:
            if periodic is None:
                self.periodic = False
            else:
                self.periodic = periodic
            self.box = None
        elif parameter_set_parmed.box is not None:
            self.box = torch.tensor(parameter_set_parmed.box[:3])  # x,y,z size of box
            assert (parameter_set_parmed.box[3] == parameter_set_parmed.box[4] and parameter_set_parmed.box[4] == parameter_set_parmed.box[5] and math.isclose(
                parameter_set_parmed.box[4], 90.0)), "We currently only support orthogonal boxes"
            self.box = self.box.to(self.dtype)
            if periodic is None:
                self.periodic = True
                if nonbonded_type == "NoCutoff":
                    warn(
                        "NoCutoff specified with box present, but not specifying periodic. Assuming implicitly cutoff at box/2. This behavior is different from OpenMM.",
                        stacklevel=2)
            else:
                self.periodic = periodic

    def update_box(self, box):
        """
        Update the simulation box dimensions.

        Parameters
        ----------
        box : torch.Tensor
            The new box dimensions
        """
        super().update_box(box)
        self.parameter_set_parmed.box = [
            box[0].item(),
            box[1].item(),
            box[2].item(),
            self.parameter_set_parmed.box[3],
            self.parameter_set_parmed.box[4],
            self.parameter_set_parmed.box[5]]


    def extract_constraints(self, constraint_option, parameter_set, rel_tol=1e-4):
        """
        Extract constraints from the parameter set.

        Parameters
        ----------
        constraint_option : str
            Option for constraints. Can be 'h_bonds', 'all_bonds', or 'h_angles'.
            - h_bonds: Constrain bonds involving hydrogen
            - all_bonds: Constrain all bonds
            - h_angles: Constrain bonds and angles involving hydrogen
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.
        rel_tol : float, optional
            Relative tolerance for mass comparisons. Default is 1e-4.

        Returns
        -------
        torch.Tensor
            Tensor containing pairs of atom indices for each constraint.
        torch.Tensor
            Tensor containing equilibrium distances for each constraint.
        """
        # We perform the identification of the elements via their mass, because naming can be ambigous.
        mass_hydrogen = 1.008
        mass_oxygen = 16.0
        constraint_atoms = []
        constraint_equilibrium = []

        visited = torch.zeros(len(parameter_set.bonds), dtype=torch.bool)
        if constraint_option in ("h_bonds", "all_bonds", "h_angles"):
            for idx, bond in enumerate(parameter_set.bonds):
                if math.isclose(bond.atom1.mass, mass_hydrogen, rel_tol=rel_tol) or math.isclose(bond.atom2.mass, mass_hydrogen, rel_tol=rel_tol):
                    constraint_atoms.append((bond.atom1.idx, bond.atom2.idx))
                    constraint_equilibrium.append(bond.type.req)
                    visited[idx] = True
        if constraint_option in ("all_bonds", "h_angles"):
            for idx, bond in enumerate(parameter_set.bonds):
                if math.isclose(
                        bond.atom1.mass,
                        mass_hydrogen,
                        rel_tol=rel_tol) and math.isclose(
                        bond.atom2.mass,
                        mass_hydrogen,
                        rel_tol=rel_tol) and not visited[idx]:
                    constraint_atoms.append((bond.atom1.idx, bond.atom2.idx))
                    constraint_equilibrium.append(bond.type.req)

        constraints_per_atom = []
        for _ in range(self.num_atoms):
            constraints_per_atom.append([])
            constraints_per_atom.append([])

        for idx, constraint in enumerate(constraint_atoms):
            constraints_per_atom[constraint[0]].append((constraint[1], constraint_equilibrium[idx]))
            constraints_per_atom[constraint[1]].append((constraint[0], constraint_equilibrium[idx]))

        if constraint_option in ("h_angles",):
            for angle in parameter_set.angles:
                num_h = (math.isclose(angle.atom1.mass, mass_hydrogen, rel_tol=rel_tol)) + (math.isclose(angle.atom3.mass, mass_hydrogen, rel_tol=rel_tol))
                if num_h == 2 and math.isclose(angle.atom2.mass, mass_oxygen, rel_tol=rel_tol):
                    for con in constraints_per_atom[angle.atom2.idx]:
                        if con[0] == angle.atom1.idx:
                            l1 = con[1]
                        elif con[0] == angle.atom3.idx:
                            l2 = con[1]
                    length_of_virtual_constraint = math.sqrt(l1 * l1 + l2 * l2 - 2 * l1 * l2 * math.cos(math.radians(angle.type.theteq)))
                    if (angle.atom1.idx, angle.atom3.idx) not in constraint_atoms:
                        constraint_atoms.append((angle.atom1.idx, angle.atom3.idx))
                        constraint_equilibrium.append(length_of_virtual_constraint)

        constraint_atoms = torch.tensor(constraint_atoms)
        constraint_equilibrium = torch.tensor(constraint_equilibrium)
        return constraint_atoms, constraint_equilibrium

    def extract_num_molecules_for_barostat(self, parameter_set_parmed):
        """
        Extract molecule information needed for barostat calculations.

        Parameters
        ----------
        parameter_set_parmed : parmed.Structure
            ParmEd structure containing force field parameters.
        """
        molecules = parmed.utils.tag_molecules(parameter_set_parmed)
        self.num_molecules = len(molecules)
        # Specific list for all molecules with length 3
        # This is to avoid inefficient loops over smaller molecules

        length3_molecules = []
        self.other_molecules = []
        for mol in molecules:
            if len(mol) == 3:
                length3_molecules.append(list(mol))
            else:
                self.other_molecules.append(torch.tensor(list(mol)))
        self.length3_molecules = torch.tensor(length3_molecules)

    def check_generic_adjusts(self, dihedrals_parameters):
        """
        Check for consistent scaling factors in dihedral parameters.

        Parameters
        ----------
        dihedrals_parameters : torch.Tensor
            Tensor containing dihedral parameters.

        Returns
        -------
        float or None
            1-4 electrostatic scaling factor (scee).
        float or None
            1-4 Lennard-Jones scaling factor (scnb).
        """
        if dihedrals_parameters.size(0) > 0:
            if not (dihedrals_parameters[:, 3] == dihedrals_parameters[0, 3]).all():
                warn("For 1-4 electrostatic interactions found different scalings. Should be handeled by explicit setting of constraint parameters. This needs much more storage.")
            if not (dihedrals_parameters[:, 4] == dihedrals_parameters[0, 4]).all():
                warn("For 1-4 LJ interactions found different scalings. Should be handeled by explicit setting of constraint parameters. This needs much more storage.")
            scee = dihedrals_parameters[0, 3].item()
            scnb = dihedrals_parameters[0, 4].item()
        else:
            scee = None
            scnb = None
        return scee, scnb

    def check_explicit_adjusts(self, parameter_set_parmed):
        """
        Check for explicit adjustments in force field parameters.

        Parameters
        ----------
        parameter_set_parmed : parmed.Structure
            ParmEd structure containing force field parameters.

        Returns
        -------
        torch.Tensor
            Sigma values for adjustments.
        torch.Tensor
            Epsilon values for adjustments.
        torch.Tensor
            List of atom pairs for adjustments.
        """
        # Check if explicit adjustments are required by the FF parameterization
        sigmas_adjust = []
        epsilons_adjust = []
        adjust_list = []
        for adjust in parameter_set_parmed.adjusts:
            sigmas_adjust.append(adjust.type.sigma**6)
            epsilons_adjust.append(adjust.type.epsilon)
            adjust_list.append((adjust.atom1.idx, adjust.atom2.idx))
            if self.scee is None: # Jump over, if there are no scee corrections at all
                continue
            if not math.isclose(1.0 / adjust.type.chgscale, self.scee, abs_tol=1e-4):
                warn("Found different rescaling of individual charges; currently not implemented. Use explicit adjustments of interactions instead", stacklevel=2)

        sigmas_adjust = torch.tensor(sigmas_adjust)
        epsilons_adjust = torch.tensor(epsilons_adjust)
        adjust_list = torch.tensor(adjust_list)
        if adjust_list.dim() == 2:
            adjust_list = adjust_list.T

        if sigmas_adjust.size(0) > 0:
            self.scnb = 1.0  # scnb not need because this is set by the explicit adjust parameters
        return sigmas_adjust, epsilons_adjust, adjust_list

    def get_cmap_parameters(self, parameter_set_parmed):
        """
        Get CMAP correction parameters from the parameter set.

        Parameters
        ----------
        parameter_set_parmed : parmed.Structure
            ParmEd structure containing force field parameters.

        Returns
        -------
        list
            List of CmapCorrection objects.
        """
        cmap_atoms = []
        for _ in range(len(parameter_set_parmed.cmap_types)):
            cmap_atoms.append([])

        for cmap in parameter_set_parmed.cmaps:
            cmap_atoms[cmap.type.idx].append([cmap.atom1.idx, cmap.atom2.idx, cmap.atom3.idx, cmap.atom4.idx, cmap.atom5.idx])

        cmap_forces = []
        for cmap_type in parameter_set_parmed.cmap_types:
            cmap_forces.append(CmapCorrection(torch.tensor(cmap_type.grid), cmap_type.resolution,
                               torch.tensor(cmap_atoms[cmap_type.idx]), self.periodic, self.box))
        return cmap_forces

    def get_nonbonded_parameters(self, parameter_set):
        """
        Get nonbonded parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        torch.Tensor
            Sigmas for nonbonded interactions.
        torch.Tensor
            Epsilons for nonbonded interactions.
        torch.Tensor
            Charges for nonbonded interactions.
        torch.Tensor
            Masses of particles.

        Raises
        ------
        Exception
            If zero mass particles are found.
        """
        sigmas = torch.zeros((self.num_atoms,), dtype=self.dtype)
        epsilons = torch.zeros((self.num_atoms,), dtype=self.dtype)
        charges = torch.zeros((self.num_atoms,), dtype=self.dtype)
        masses = torch.zeros((self.num_atoms,), dtype=self.dtype)

        for idx, atom in enumerate(parameter_set.atoms):
            masses[idx] = atom.mass
            sigmas[idx] = atom.sigma
            epsilons[idx] = atom.epsilon
            charges[idx] = atom.charge

        if torch.any(masses == 0.0):
            raise Exception("Found zero mass particles, most likely stemming from tip4p molecules or virtual sites. This is currently not supported.")

        return sigmas, epsilons, charges, masses

    def get_angle_parameters(self, parameter_set):
        """
        Get angle parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        torch.Tensor
            List of angles as triplets of atom indices.
        torch.Tensor
            Angle parameters (force constant, equilibrium angle).
        torch.Tensor
            Angle exclusions as pairs of atom indices.
        """
        if hasattr(parameter_set, 'angles_inc_h'):
            if len(list(parameter_set.angles_inc_h)) < 0.05 * self.num_atoms and self.box is not None:
                warn(
                    f"Only found {len(list(parameter_set.angles_inc_h))} angles including hydrogen, but there are {self.num_atoms} atoms in total, indicating that angle interactions in water are missing. Is this intended (can be if constraints are used)?",
                    stacklevel=2)

        angle_list = []
        angle_parameters = []
        angle_exclusions = []
        for angle in parameter_set.angles:
            if self.excluded_bonded_atoms is None or (
                    angle.atom1.idx not in self.excluded_bonded_atoms and angle.atom2.idx not in self.excluded_bonded_atoms and angle.atom3.idx not in self.excluded_bonded_atoms):
                angle_list.append((angle.atom1.idx, angle.atom2.idx, angle.atom3.idx))
                angle_exclusions.append((angle.atom1.idx, angle.atom3.idx))
                angle_parameters.append((angle.type.k, math.radians(angle.type.theteq)))
        angle_list = torch.tensor(angle_list)
        angle_exclusions = torch.tensor(angle_exclusions, dtype=torch.int64)
        if angle_exclusions.dim() == 2:
            angle_exclusions = angle_exclusions.T
        angle_parameters = torch.tensor(angle_parameters, dtype=self.dtype)

        return angle_list, angle_parameters, angle_exclusions

    def get_bond_parameters(self, parameter_set):
        """
        Get bond parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        torch.Tensor
            Bond parameters (force constant, equilibrium distance).
        torch.Tensor
            List of bonds as pairs of atom indices.
        torch.Tensor
            List of bonds as pairs of atom indices (duplicate).
        """
        bond_parameters = []
        bond_list = []
        for bond in parameter_set.bonds:
            if self.excluded_bonded_atoms is None or (
                    bond.atom1.idx not in self.excluded_bonded_atoms and bond.atom2.idx not in self.excluded_bonded_atoms):
                bond_list.append([bond.atom1.idx, bond.atom2.idx])
                bond_parameters.append((bond.type.k, bond.type.req))
        bond_list = torch.tensor(bond_list, dtype=torch.int64)
        if bond_list.dim() == 2:
            bond_list = bond_list.T
        bond_parameters = torch.tensor(bond_parameters, dtype=self.dtype)
        return bond_parameters, bond_list, bond_list

    def get_urey_bradley(self, parameter_set):
        """
        Get Urey-Bradley parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        torch.Tensor
            Bond parameters (force constant, equilibrium distance).
        torch.Tensor
            List of bonds as pairs of atom indices.
        torch.Tensor
            List of bonds as pairs of atom indices (duplicate).
        """
        bond_parameters = []
        bond_list = []
        for bond in parameter_set.urey_bradleys:
            if self.excluded_bonded_atoms is None or (
                    bond.atom1.idx not in self.excluded_bonded_atoms and bond.atom2.idx not in self.excluded_bonded_atoms):
                bond_list.append([bond.atom1.idx, bond.atom2.idx])
                bond_parameters.append((bond.type.k, bond.type.req))

        bond_list = torch.tensor(bond_list, dtype=torch.int64)
        if bond_list.dim() == 2:
            bond_list = bond_list.T
        bond_parameters = torch.tensor(bond_parameters, dtype=self.dtype)
        return bond_parameters, bond_list, bond_list

    def get_dihedral_parameters(self, parameter_set):
        """
        Get dihedral parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Raises
        ------
        NotImplementedError
            If the method is not implemented in the subclass.
        """
        raise NotImplementedError("Dihedral reading is different for Gromacs and Amber and needs to be implemented in subclass")

    def write_pdb(self, positions, output, unwrap=True):
        """
        Write the positions to a PDB file.

        Parameters
        ----------
        positions : torch.Tensor
            The positions of the atoms.
        output : str or file-like object
            The output file or file path.
        unwrap : bool, optional
            Whether to unwrap molecules across periodic boundaries (default is True).
        """
        def mean_position(positions, box):
            position_angles = 2.0 * torch.pi * positions / box.unsqueeze(0).unsqueeze(0)
            cosine_avg = torch.mean(torch.cos(position_angles), dim=1)
            sine_avg = torch.mean(torch.sin(position_angles), dim=1)
            theta_avg = torch.arctan2(sine_avg, cosine_avg)
            return (theta_avg * box / (2.0 * torch.pi)) % box
        
        local_positions = torch.empty_like(positions).copy_(positions)

        if isinstance(output, str):
            output_file = open(output, "a")
        else:
            output_file = output

        if unwrap and self.box is not None and hasattr(self, "length3_molecules") and hasattr(self, "other_molecules"):
            water_positions = local_positions[self.length3_molecules]
            water_centers = mean_position(water_positions, self.box).unsqueeze(1)
            offset = periodic_correction(water_positions - water_centers, self.box)
            local_positions[self.length3_molecules] = water_centers + offset

            for mol in self.other_molecules:
                molecule_positions = local_positions[mol]
                molecule_center = mean_position(molecule_positions.unsqueeze(0), self.box).squeeze(0)
                offset = periodic_correction(molecule_positions - molecule_center, self.box)
                local_positions[mol] = molecule_center + offset

        output_file.write('MODEL      %5d\n' % (self.pdb_counter + 1))
        self.pdb_writer.write(self.parameter_set_parmed, output_file, coordinates=local_positions.to(torch.device("cpu")).detach().numpy())
        output_file.write('ENDMDL\n')
        self.pdb_counter += 1

    def as_mace_system(self, mace_name, enable_cueq=True, atom_range=None):
        """
        Convert to a MACE system.

        Parameters
        ----------
        mace_name : str
            Name of the MACE model.
        enable_cueq : bool, optional
            Whether to enable charge equilibration (default is True).
        atom_range : tuple, optional
            Range of atoms to include (start, end).

        Returns
        -------
        MaceFoundationalSystem
            The converted system.
        """
        from dimos.mlip.mace import MaceFoundationalSystem

        if atom_range is None:
            num_atoms = len(self.parameter_set_parmed.atoms)
        else:
            num_atoms = atom_range[1]-atom_range[0]
        
        atomic_numbers = torch.zeros((num_atoms), dtype=torch.int64)
        masses = torch.zeros((num_atoms), dtype=torch.get_default_dtype())

        if atom_range is not None:
            local_idx = 0
            for idx, atom in enumerate(self.parameter_set_parmed.atoms):
                if not (idx>=atom_range[0] and idx < atom_range[1]):
                    continue
                atomic_numbers[local_idx] = atom.atomic_number
                masses[local_idx] = atom.mass
                local_idx = local_idx + 1
        else:
            for idx, atom in enumerate(self.parameter_set_parmed.atoms):
                atomic_numbers[idx] = atom.atomic_number
                masses[idx] = atom.mass

        system = MaceFoundationalSystem(
            masses,
            atomic_numbers,
            mace_name=mace_name,
            atom_range=atom_range,
            enable_cueq=enable_cueq,
            box=self.box,
            periodic=self.periodic,
            dtype=self.dtype)
        system.constraint_handler = self.constraint_handler

        return system

    def as_orb_system(self, orb_name="orb_v2", atom_range=None):
        """
        Convert to an ORB system.

        Parameters
        ----------
        orb_name : str, optional
            Name of the ORB model (default is "orb_v2").
        atom_range : tuple, optional
            Range of atoms to include (start, end).

        Returns
        -------
        OrbFoundationalSystem
            The converted system.
        """
        from dimos.mlip.orb import OrbFoundationalSystem

        if atom_range is None:
            num_atoms = len(self.parameter_set_parmed.atoms)
        else:
            num_atoms = atom_range[1]-atom_range[0]

        atomic_numbers = torch.zeros((num_atoms), dtype=torch.int64)
        masses = torch.zeros((num_atoms), dtype=torch.get_default_dtype())

        if atom_range is not None:
            local_idx = 0
            for idx, atom in enumerate(self.parameter_set_parmed.atoms):
                if not (idx>=atom_range[0] and idx < atom_range[1]):
                    continue
                atomic_numbers[local_idx] = atom.atomic_number
                masses[local_idx] = atom.mass
                local_idx = local_idx + 1
        else:
            for idx, atom in enumerate(self.parameter_set_parmed.atoms):
                atomic_numbers[idx] = atom.atomic_number
                masses[idx] = atom.mass

        system = OrbFoundationalSystem(masses, atomic_numbers, orb_name=orb_name, box=self.box, periodic=self.periodic, dtype=self.dtype)
        system.constraint_handler = self.constraint_handler

        return system


class AmberForceField(ClassicalParmedForceField):
    """
    A class to represent an Amber force field.

    Attributes
    ----------
    parameter_set : parmed.amber.AmberParm
        ParmEd structure containing the force field parameters.
    masses : torch.Tensor
        Tensor containing the masses of the atoms.
    """

    def get_dihedral_parameters(self, parameter_set):
        """
        Get dihedral parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        dihedrals : torch.Tensor
            Tensor containing dihedral atom indices.
        dihedrals_parameters : torch.Tensor
            Tensor containing dihedral parameters.
        dihedral_exclusions : torch.Tensor
            Tensor containing dihedral exclusions.
        impropers : torch.Tensor
            Tensor containing improper dihedral atom indices.
        impropers_parameters : torch.Tensor
            Tensor containing improper dihedral parameters.
        """
        CHARMM = False
        temp_dihedral_list = []
        temp_dihedral_list_exclusion = []
        temp_dihedral_parameter_list = []
        temp_improper_list = []
        temp_improper_parameter_list = []

        for dihedral in parameter_set.dihedrals:
            if self.excluded_bonded_atoms is None or (
                    dihedral.atom1.idx not in self.excluded_bonded_atoms and dihedral.atom2.idx not in self.excluded_bonded_atoms and dihedral.atom3.idx not in self.excluded_bonded_atoms and dihedral.atom4.idx not in self.excluded_bonded_atoms):
                if dihedral.improper:
                    temp_improper_list.append([dihedral.atom1.idx, dihedral.atom2.idx, dihedral.atom3.idx, dihedral.atom4.idx])
                    temp_improper_parameter_list.append([dihedral.type.phi_k, dihedral.type.per, math.radians(
                        dihedral.type.phase), dihedral.type.scee, dihedral.type.scnb])
                else:
                    if dihedral.ignore_end is False:
                        temp_dihedral_list_exclusion.append([dihedral.atom1.idx, dihedral.atom4.idx])
                    temp_dihedral_list.append([dihedral.atom1.idx, dihedral.atom2.idx, dihedral.atom3.idx, dihedral.atom4.idx])
                    temp_dihedral_parameter_list.append([dihedral.type.phi_k, dihedral.type.per, math.radians(
                        dihedral.type.phase), dihedral.type.scee, dihedral.type.scnb])

        dihedrals = torch.tensor(temp_dihedral_list)
        impropers = torch.tensor(temp_improper_list)

        dihedrals_parameters = torch.tensor(temp_dihedral_parameter_list, dtype=self.dtype)
        impropers_parameters = torch.tensor(temp_improper_parameter_list, dtype=self.dtype)

        dihedral_exclusions = torch.tensor(temp_dihedral_list_exclusion, dtype=torch.int64)
        if dihedral_exclusions.dim() == 2:
            dihedral_exclusions = dihedral_exclusions.T
        return dihedrals, dihedrals_parameters, dihedral_exclusions, impropers, impropers_parameters, CHARMM


class GromacsForceField(ClassicalParmedForceField):
    """
    A class to represent a force field using Gromacs parameters.

    Attributes
    ----------
    parameter_set : parmed.gromacs.GromacsTopologyFile
        ParmEd structure containing the force field parameters.
    masses : torch.Tensor
        Tensor containing the masses of the atoms.
    """

    def get_dihedral_parameters(self, parameter_set):
        """
        Get dihedral parameters from the parameter set.

        Parameters
        ----------
        parameter_set : parmed.Structure
            ParmEd structure containing the force field parameters.

        Returns
        -------
        dihedrals : torch.Tensor
            Tensor containing dihedral atom indices.
        dihedrals_parameters : torch.Tensor
            Tensor containing dihedral parameters.
        dihedral_exclusions : torch.Tensor
            Tensor containing dihedral exclusions.
        impropers : torch.Tensor
            Tensor containing improper dihedral atom indices.
        impropers_parameters : torch.Tensor
            Tensor containing improper dihedral parameters.
        CHARMM : bool
            Whether CHARMM-style impropers are used.
        """
        CHARMM = False
        temp_dihedral_list = []
        temp_dihedral_list_exclusion = []
        temp_dihedral_parameter_list = []
        temp_improper_list = []
        temp_improper_parameter_list = []

        improper_counter = 0
        for dihedral in parameter_set.dihedrals:
            if self.excluded_bonded_atoms is None or (
                    dihedral.atom1.idx not in self.excluded_bonded_atoms and dihedral.atom2.idx not in self.excluded_bonded_atoms and dihedral.atom3.idx not in self.excluded_bonded_atoms and dihedral.atom4.idx not in self.excluded_bonded_atoms):
                if dihedral.improper:
                    improper_counter += 1
                    if dihedral.type.per == 0:
                        continue
                    temp_improper_list.append([dihedral.atom1.idx, dihedral.atom2.idx, dihedral.atom3.idx, dihedral.atom4.idx])
                    temp_improper_parameter_list.append([dihedral.type.phi_k, dihedral.type.per, math.radians(
                        dihedral.type.phase), dihedral.type.scee, dihedral.type.scnb])
                else:
                    if dihedral.ignore_end is False:
                        temp_dihedral_list_exclusion.append([dihedral.atom1.idx, dihedral.atom4.idx])
                    if isinstance(dihedral.type, parmed.DihedralTypeList):
                        for typ in dihedral.type:
                            if typ.per == 0:
                                continue
                            temp_dihedral_list.append([dihedral.atom1.idx, dihedral.atom2.idx, dihedral.atom3.idx, dihedral.atom4.idx])
                            temp_dihedral_parameter_list.append([typ.phi_k, typ.per, math.radians(typ.phase), typ.scee, typ.scnb])
                    else:
                        typ = dihedral.type
                        if typ.per == 0:
                            continue
                        temp_dihedral_list.append([dihedral.atom1.idx, dihedral.atom2.idx, dihedral.atom3.idx, dihedral.atom4.idx])
                        temp_dihedral_parameter_list.append([typ.phi_k, typ.per, math.radians(typ.phase), typ.scee, typ.scnb])

        # CHARMM FF
        if improper_counter == 0 and len(parameter_set.impropers) > 0:
            CHARMM = True
            for improper in parameter_set.impropers:
                temp_improper_list.append([improper.atom1.idx, improper.atom2.idx, improper.atom3.idx, improper.atom4.idx])
                temp_improper_parameter_list.append([improper.type.psi_k, improper.type.psi_eq])

        dihedrals = torch.tensor(temp_dihedral_list)
        impropers = torch.tensor(temp_improper_list)

        dihedrals_parameters = torch.tensor(temp_dihedral_parameter_list, dtype=self.dtype)
        impropers_parameters = torch.tensor(temp_improper_parameter_list, dtype=self.dtype)

        dihedral_exclusions = torch.tensor(temp_dihedral_list_exclusion, dtype=torch.int64)
        if dihedral_exclusions.dim() == 2:
            dihedral_exclusions = dihedral_exclusions.T

        return dihedrals, dihedrals_parameters, dihedral_exclusions, impropers, impropers_parameters, CHARMM
